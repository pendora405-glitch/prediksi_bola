<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Match Simulation Engine — PRIME SINGULARITY ZERO ∑.0</title>

<style>
  body {
    background:#050505;
    color:#f2f2f2;
    font-family:Arial, sans-serif;
    padding:20px;
  }
  h1 {
    font-size:26px;
    margin-bottom:15px;
    color:#7bf7ff;
  }
  h2 {
    font-size:18px;
    margin-bottom:8px;
    color:#e2e2e2;
  }
  .section {
    padding:10px 15px;
    border:1px solid #444;
    margin-bottom:15px;
    border-radius:7px;
    background:#141414;
  }
  label { 
    display:block; 
    margin-top:7px; 
    font-size:13px;
  }
  input {
    width:100%;
    padding:6px;
    margin-top:4px;
    background:#202020;
    border:1px solid #555;
    color:#f2f2f2;
    border-radius:5px;
    font-size:13px;
    box-sizing:border-box;
  }
  button {
    padding:10px 15px;
    background:#12b8e3;
    color:#000;
    border:none;
    border-radius:6px;
    cursor:pointer;
    margin-top:15px;
    font-weight:bold;
  }
  button:hover {
    background:#18c9f5;
  }
  textarea {
    width:100%;
    height:340px;
    background:#050505;
    color:#00ff66;
    padding:10px;
    border:1px solid #333;
    margin-top:10px;
    border-radius:5px;
    font-family:monospace;
    font-size:12px;
    white-space:pre;
    box-sizing:border-box;
  }
  small {
    color:#aaa;
    font-size:11px;
  }
  .triple-input {
    display:flex;
    gap:6px;
  }
  .triple-input input {
    width:33.33%;
  }
</style>
</head>

<body>

<h1>Match Simulation Engine — PRIME SINGULARITY ZERO ∑.0</h1>

<!-- =========================
     INPUT STATISTIK UTAMA
========================= -->
<div class="section">
  <h2>Input Statistik Utama</h2>

  <label>Expected Goals Home (λH)</label>
  <input id="lamH" type="number" min="0.1" max="5" step="0.05" placeholder="mis: 1.60">

  <label>Expected Goals Away (λA)</label>
  <input id="lamA" type="number" min="0.1" max="5" step="0.05" placeholder="mis: 1.20">

  <label>Tempo (1–10) <small>(kecepatan ritme pertandingan)</small></label>
  <input id="tempo" type="number" min="1" max="10" placeholder="5">

  <label>Chaos (1–10) <small>(seberapa liar / tidak terstruktur)</small></label>
  <input id="chaos" type="number" min="1" max="10" placeholder="5">

  <label>Importance (1–10) <small>(pentingnya pertandingan: final, derby, dsb.)</small></label>
  <input id="importance" type="number" min="1" max="10" placeholder="5">
</div>

<!-- =========================
     DATA TIM
========================= -->
<div class="section">
  <h2>Data Tim</h2>

  <label>Home Stability (1–10) <small>(soliditas & konsistensi pertahanan)</small></label>
  <input id="home_st" type="number" min="1" max="10" placeholder="5">

  <label>Away Stability (1–10)</label>
  <input id="away_st" type="number" min="1" max="10" placeholder="5">

  <label>Home Momentum (1–10) <small>(form & mental saat ini)</small></label>
  <input id="home_mom" type="number" min="1" max="10" placeholder="5">

  <label>Away Momentum (1–10)</label>
  <input id="away_mom" type="number" min="1" max="10" placeholder="5">
</div>

<!-- =========================
     TAKTIK & FLEKSIBILITAS
========================= -->
<div class="section">
  <h2>Taktik & Fleksibilitas</h2>

  <label>Home Press Intensity (1–10)</label>
  <input id="home_press" type="number" min="1" max="10" placeholder="5">

  <label>Away Press Intensity (1–10)</label>
  <input id="away_press" type="number" min="1" max="10" placeholder="5">

  <label>Home Flex (0–1) <small>(0 = formasi kaku, 1 = sangat fleksibel)</small></label>
  <input id="home_flex" type="number" min="0" max="1" step="0.05" placeholder="0.5">

  <label>Away Flex (0–1)</label>
  <input id="away_flex" type="number" min="0" max="1" step="0.05" placeholder="0.5">

  <small>
    Catatan: jika tim hanya memakai 1 formasi & jarang berubah, isi flex sekitar 0.1–0.3.  
    Jika sering ganti formasi (2–3 variasi), flex 0.5–0.8 lebih cocok.
  </small>
</div>

<!-- =========================
     ADVANCED AUTO-CALC INPUT WAJIB
========================= -->
<div class="section">
  <h2>Advanced Stats (Auto-Calc Input Wajib)</h2>

  <label>xG Home (rata-rata 5 laga terakhir)</label>
  <input id="adv_xg_home" type="number" step="0.01" placeholder="mis: 1.70">

  <label>xG Away (rata-rata 5 laga terakhir)</label>
  <input id="adv_xg_away" type="number" step="0.01" placeholder="mis: 1.30">

  <label>xGA Home (rata-rata xG kebobolan per laga)</label>
  <input id="adv_xga_home" type="number" step="0.01" placeholder="mis: 1.10">

  <label>xGA Away (rata-rata xG kebobolan per laga)</label>
  <input id="adv_xga_away" type="number" step="0.01" placeholder="mis: 1.40">

  <label>Form Home (W-D-L, 5 laga terakhir)</label>
  <div class="triple-input">
    <input id="adv_form_home_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_home_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_home_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>Form Away (W-D-L, 5 laga terakhir)</label>
  <div class="triple-input">
    <input id="adv_form_away_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_away_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_away_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>PPDA Home (rata-rata, makin rendah = press tinggi)</label>
  <input id="adv_ppda_home" type="number" step="0.1" placeholder="mis: 8.0">

  <label>PPDA Away</label>
  <input id="adv_ppda_away" type="number" step="0.1" placeholder="mis: 10.5">

  <label>Error Defensif Home per laga (perkiraan)</label>
  <input id="adv_err_home" type="number" step="0.1" placeholder="mis: 0.8">

  <label>Error Defensif Away per laga</label>
  <input id="adv_err_away" type="number" step="0.1" placeholder="mis: 1.2">

  <label>Jumlah Formasi Aktif Home (1–3)</label>
  <input id="adv_formasi_home" type="number" min="1" max="3" placeholder="mis: 2">

  <label>Jumlah Formasi Aktif Away (1–3)</label>
  <input id="adv_formasi_away" type="number" min="1" max="3" placeholder="mis: 1">

  <button id="btn_auto_calc">AUTO-CALC INPUT WAJIB</button>
  <small>
    Tombol ini akan mengisi otomatis λH, λA, Momentum, Stability, Press, dan Flex  
    berdasarkan data advanced di atas.
  </small>
</div>

<!-- =========================
     PARAMETER SIMULASI
========================= -->
<div class="section">
  <h2>Parameter Simulasi</h2>

  <label>SimCount (Default 50000)</label>
  <input id="simCount" type="number" min="5000" max="300000" placeholder="kosongkan untuk default">

  <label>Score Cap (3–8, default auto)</label>
  <input id="scoreCap" type="number" min="3" max="8" placeholder="kosongkan untuk auto">

  <button id="btn_analyze">ANALYZE PRIME SINGULARITY ZERO</button>
</div>

<!-- =========================
     OUTPUT
========================= -->
<div class="section">
  <h2>Output</h2>
  <textarea id="output" readonly></textarea>
</div>

<!-- SCRIPT PARTS AKAN DITEMPEL DI BAWAH INI (PART 2–5) -->
<script>
// =============================================================
// PART 2 — NAMESPACE + UTILITY + POISSON + RANDOM CORE
// =============================================================

/*  
   Semua fungsi engine ada di namespace V20
   supaya aman, tidak tabrakan dengan script lain.
*/
const V20 = {};

// ---------------------------
// Number parsing safety
// ---------------------------
V20.num = function(v, fallback = 0){
  const n = Number(v);
  return isFinite(n) ? n : fallback;
};

// ---------------------------
// Clamp helper
// ---------------------------
V20.clamp = function(value, min, max){
  if (value < min) return min;
  if (value > max) return max;
  return value;
};

// ---------------------------
// Log factorial cache
// (dipakai Poisson PMF)
// ---------------------------
V20._logFactorialCache = [0];
V20._logFactorial = function(n){
  const cache = V20._logFactorialCache;
  if (cache[n] != null) return cache[n];

  let val = cache[cache.length - 1];
  for (let i = cache.length; i <= n; i++){
    val += Math.log(i);
    cache[i] = val;
  }
  return cache[n];
};

// ---------------------------
// Poisson PMF (probabilitas k gol)
// ---------------------------
V20.poissonPMF = function(lambda, k){
  lambda = Math.max(lambda, 0.00001);
  if (k < 0) return 0;
  return Math.exp(-lambda + k*Math.log(lambda) - V20._logFactorial(k));
};

// ---------------------------
// Random Poisson sampler
// (dipakai MC & chaos sim)
// ---------------------------
V20.samplePoisson = function(lambda){
  lambda = Math.max(lambda, 0.00001);
  const L = Math.exp(-lambda);
  let p = 1, k = 0;
  do {
    p *= Math.random();
    k++;
  } while (p > L);
  return k - 1;
};

// ---------------------------
// Normalize array jadi proporsi
// ---------------------------
V20.normalize = function(arr){
  let s = 0;
  for (let x of arr) s += x;
  if (!s) return arr.map(() => 1/arr.length);
  return arr.map(x => x/s);
};

// =============================================================
// PART 2 SELESAI
// Lanjut ke PART 3 untuk:
// • Pattern Oracle
// • God Hyper Lambda
// • Monte Carlo Engine
// =============================================================
</script>
<script>
// =============================================================
// PART 3 — PATTERN ORACLE + HYPER LAMBDA + MONTE CARLO
// =============================================================

// -------------------------------------------------------------
// PATTERN ORACLE
// -------------------------------------------------------------
V20.patternOracle = function(ctx, home, away, tact){
  ctx  = ctx  || {};
  home = home || {stability:5, momentum:5};
  away = away || {stability:5, momentum:5};
  tact = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;
  const imp   = ctx.importance || 5;

  const stH = home.stability || 5;
  const stA = away.stability || 5;
  const stabAvg = (stH + stA)/2;

  const momGap   = (home.momentum || 5) - (away.momentum || 5);
  const pressGap = (tact.home.pressIntensity || 5) - (tact.away.pressIntensity || 5);

  const tempoF = (tempo - 5)/5;
  const chaosF = (chaos - 5)/5;
  const impF   = (imp   - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  // Probabilitas pattern (control/swing/stalled/chaotic)
  let control = 0.35 
              - chaosF*0.20
              + stabF*0.25
              + impF*0.05;

  let swing   = 0.25
              + Math.abs(momGap)*0.04
              + Math.abs(pressGap)*0.05
              + tempoF*0.15;

  let stalled = 0.15
              + (-tempoF)*0.20
              + stabF*0.15;

  let chaotic = 0.25
              + chaosF*0.35
              + tempoF*0.15
              - stabF*0.10;

  control = Math.max(control, 0.01);
  swing   = Math.max(swing  , 0.01);
  stalled = Math.max(stalled, 0.01);
  chaotic = Math.max(chaotic, 0.01);

  let sum = control + swing + stalled + chaotic;
  const pattern = {
    control: control/sum,
    swing:   swing/sum,
    stalled: stalled/sum,
    chaotic: chaotic/sum
  };

  // Dominant pattern
  let dom = "control";
  let maxVal = pattern.control;
  if (pattern.swing   > maxVal){ dom="swing";   maxVal=pattern.swing; }
  if (pattern.stalled > maxVal){ dom="stalled"; maxVal=pattern.stalled; }
  if (pattern.chaotic > maxVal){ dom="chaotic"; maxVal=pattern.chaotic; }

  return { pattern, dominant: dom };
};

// -------------------------------------------------------------
// HYPER LAMBDA (GOD ENGINE BASE)
// -------------------------------------------------------------
V20.godHyperLambda = function(lambda, ctx, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  let lamH = V20.num(lambda.lamH, 1.2);
  let lamA = V20.num(lambda.lamA, 1.0);

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const stH  = home.stability || 5;
  const stA  = away.stability || 5;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;

  const momGap   = momH - momA;
  const pressGap = pressH - pressA;
  const stabAvg  = (stH + stA)/2;

  // Pattern Oracle
  const PO  = V20.patternOracle(ctx, home, away, tact);
  const pat = PO.pattern;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  // Control → sedikit menahan agresi
  lamH *= (1 - pat.control*0.05);
  lamA *= (1 - pat.control*0.05);

  // Swing → mengikuti momentum + tekanan
  const swingH = pat.swing * (Math.max(0,momGap)/10 + Math.max(0,pressGap)/10);
  const swingA = pat.swing * (Math.max(0,-momGap)/10 + Math.max(0,-pressGap)/10);
  lamH *= (1 + swingH*0.22);
  lamA *= (1 + swingA*0.22);

  // Stalled → menekan tempo
  lamH *= (1 - pat.stalled*0.10);
  lamA *= (1 - pat.stalled*0.10);

  // Chaotic → membuka peluang
  lamH *= (1 + pat.chaotic*0.25);
  lamA *= (1 + pat.chaotic*0.25);

  // Tekanan langsung
  lamH *= (1 + (pressH-5)*0.015);
  lamA *= (1 + (pressA-5)*0.015);

  // Fleksibilitas formasi
  lamH *= (1 + flexH*0.05);
  lamA *= (1 + flexA*0.05);

  // Momentum + Chaos global
  lamH *= (1 + chaosF*0.10 + tempoF*0.02);
  lamA *= (1 + chaosF*0.10 + tempoF*0.02);

  lamH = V20.clamp(lamH, 0.20, 6.00);
  lamA = V20.clamp(lamA, 0.20, 6.00);

  return {
    lamH,
    lamA,
    pattern: pat,
    dominantPattern: PO.dominant
  };
};

// -------------------------------------------------------------
// MONTE CARLO — Divine Multi-Reality Engine
// -------------------------------------------------------------
V20.monteCarlo = function(lambda, ctx, simCount, scoreCap, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  const god = V20.godHyperLambda(lambda, ctx, home, away, tact);
  const lamH_base = god.lamH;
  const lamA_base = god.lamA;
  const totalLam  = lamH_base + lamA_base || 0.0001;

  const pat   = god.pattern;
  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;
  const imp   = ctx.importance || 5;
  const stabAvg = (home.stability + away.stability)/2;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const impF   = (imp   - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  // Default simcount
  const baseSim = simCount ? V20.num(simCount) : 50000;

  // Noise berdasarkan pattern
  let patternScale =
      1.00
    + pat.swing   * 0.30
    + pat.chaotic * 0.35
    - pat.stalled * 0.25;

  const globalAdj =
      chaosF*0.35 +
      tempoF*0.25 +
      impF  *0.15 -
      stabF *0.20;

  let simScaled = baseSim * (1 + globalAdj*0.7) * patternScale;
  simScaled = V20.clamp(simScaled, 30000, 280000);
  simCount  = Math.round(simScaled);

  // Score cap
  const autoCap = totalLam > 3.4 ? 6 : 5;
  scoreCap = V20.clamp(scoreCap || autoCap, 3, 8);

  // 3 Phase (Early/Mid/Late)
  const phases = {
    early:1,
    mid:1,
    late:1,
    wEarly:0.25,
    wMid:0.50,
    wLate:0.25
  };

  let wSum = phases.wEarly + phases.wMid + phases.wLate;
  if (!wSum || !isFinite(wSum)) wSum = 1;

  const phaseList = [
    {name:"early", w:phases.wEarly/wSum, m:phases.early},
    {name:"mid",   w:phases.wMid  /wSum, m:phases.mid},
    {name:"late",  w:phases.wLate /wSum, m:phases.late}
  ];
  let acc=0;
  phaseList.forEach(p=>{ acc+=p.w; p.cum=acc; });

  function pickPhase(){
    const r = Math.random();
    for (let i=0;i<phaseList.length;i++){
      if(r <= phaseList[i].cum) return phaseList[i];
    }
    return phaseList[phaseList.length-1];
  }

  // Reality A/B/C
  function realityParams(type){
    let fH=1, fA=1, spread=0.6;
    if(type==="A"){
      fH=1.00; fA=1.00; spread=0.45;
    } else if(type==="B"){
      fH=1.00 + Math.max(0,chaosF)*0.20;
      fA=1.00 + Math.max(0,chaosF)*0.20;
      spread = 0.7 + Math.max(0,chaosF)*0.7;
    } else {
      const swingBoost   = pat.swing*0.10;
      const chaoticBoost = pat.chaotic*0.12;
      fH = 1.00 + swingBoost + chaoticBoost;
      fA = 1.00 + swingBoost + chaoticBoost;
      spread = 0.6 + (pat.chaotic+pat.swing)*0.7;
    }
    return {fH,fA,spread};
  }

  const realityWeights = {
    A: 0.40 + pat.control*0.20,
    B: 0.30 + pat.chaotic*0.30,
    C: 0.30 + pat.swing*0.30
  };
  let wR = realityWeights.A + realityWeights.B + realityWeights.C;
  realityWeights.A/=wR; realityWeights.B/=wR; realityWeights.C/=wR;

  function pickReality(){
    const r = Math.random();
    if (r <= realityWeights.A) return "A";
    if (r <= realityWeights.A + realityWeights.B) return "B";
    return "C";
  }

  // Scenario list (base, control, swing, stalled, chaotic, homeFront, awayFront, wideOpen)
  const ratioH = lamH_base / totalLam;
  const ratioA = 1 - ratioH;

  const scenarios = [
    {name:"base",      w:0.30, fH:1.00, fA:1.00},
    {name:"control",   w:0.08 + 0.25*pat.control, fH:0.97, fA:0.97},
    {name:"swing",     w:0.08 + 0.25*pat.swing,   fH:1.07, fA:1.07},
    {name:"stalled",   w:0.06 + 0.22*pat.stalled, fH:0.78, fA:0.78},
    {name:"chaotic",   w:0.06 + 0.22*pat.chaotic, fH:1.18, fA:1.18},
    {name:"homeFront", w:0.06 + 0.10*ratioH,      fH:1.08, fA:0.97},
    {name:"awayFront", w:0.06 + 0.10*ratioA,      fH:0.97, fA:1.08},
    {name:"wideOpen",  w:0.04 + 0.12*Math.max(0,tempoF)*Math.max(0,chaosF), fH:1.22, fA:1.22}
  ];

  // Penalti kondisi tertentu
  scenarios.forEach(s=>{
    if(s.name==="wideOpen") s.w *= 0.90;
    if(s.name==="chaotic")  s.w *= 0.93;
    if(s.name==="stalled")  s.w *= 0.95;
  });

  let sumSc = 0;
  scenarios.forEach(s=>sumSc+=s.w);
  scenarios.forEach(s=>s.p = s.w/sumSc);

  const cumSc=[];
  let cs=0;
  for(let i=0;i<scenarios.length;i++){
    cs += scenarios[i].p;
    cumSc[i]=cs;
  }

  function pickScenario(){
    const r = Math.random();
    for(let i=0;i<cumSc.length;i++){
      if(r<=cumSc[i]) return scenarios[i];
    }
    return scenarios[scenarios.length-1];
  }

  // Hybrid sample (Poisson +Noise)
  function sampleHybrid(lambdaBase, spreadBase){
    lambdaBase = Math.max(lambdaBase, 0.00001);
    const r = Math.random();
    if(r < 0.55){
      return V20.samplePoisson(lambdaBase);
    } else if(r < 0.85){
      const factor = Math.exp((Math.random()-0.5)*spreadBase);
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.2);
      return V20.samplePoisson(lamVar);
    } else {
      const factor = Math.exp((Math.random()-0.5)*(spreadBase+0.4));
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.8);
      return V20.samplePoisson(lamVar);
    }
  }

  // Simulation counters
  let homeWins=0, draws=0, awayWins=0;
  let total=0, goalsTotal=0;

  const matrix=[];
  for(let h=0;h<=scoreCap;h++){
    matrix[h]=[];
    for(let a=0;a<=scoreCap;a++){
      matrix[h][a]=0;
    }
  }

  const scenarioCount={};
  scenarios.forEach(s=>scenarioCount[s.name]=0);

  // =============================
  // MAIN SIMULATION LOOP
  // =============================
  for(let i=0;i<simCount;i++){
    const phase   = pickPhase();
    const sc      = pickScenario();
    const reality = pickReality();

    scenarioCount[sc.name]++;

    const baseLamH = lamH_base * phase.m * sc.fH;
    const baseLamA = lamA_base * phase.m * sc.fA;

    const rp = realityParams(reality);
    const lamH_sim = baseLamH * rp.fH;
    const lamA_sim = baseLamA * rp.fA;

    const h = sampleHybrid(lamH_sim, rp.spread);
    const a = sampleHybrid(lamA_sim, rp.spread);

    total++;
    goalsTotal += (h+a);

    if(h>a) homeWins++;
    else if(h===a) draws++;
    else awayWins++;

    if(h<=scoreCap && a<=scoreCap){
      matrix[h][a]++;
    }
  }

  const pH = homeWins/total;
  const pD = draws/total;
  const pA = awayWins/total;
  const avgGoals = goalsTotal/total;

  // analytic OU (Poisson)
  let lamEff = totalLam;
  lamEff *= (1 + chaosF*0.10 + tempoF*0.05);
  lamEff = V20.clamp(lamEff, 0.5, 5.8);

  const lines = [0.5,1.5,2.5,3.5];
  const ou   = {};
  const ouAn = {};
  const ouMC = {};

  lines.forEach(line=>{
    let under=0;
    for(let k=0;k<=Math.floor(line);k++){
      under += V20.poissonPMF(lamEff,k);
    }
    ouAn[line]={under, over:1-under};
  });

  lines.forEach(line=>{
    const cut = Math.floor(line);
    let under=0, over=0;
    for(let h=0;h<=scoreCap;h++){
      for(let a=0;a<=scoreCap;a++){
        const sum=h+a;
        if(sum<=cut) under+=matrix[h][a];
        else over+=matrix[h][a];
      }
    }
    ouMC[line]={under:under/total,over:over/total};
  });

  // Blend analytic + MC
  const patternChaos = pat.chaotic + pat.swing*0.6;
  const wMC = 0.40 + 0.40*Math.max(0,patternChaos);
  const wAN = 1 - wMC;

  lines.forEach(line=>{
    ou[line] = {
      over: ouAn[line].over *wAN + ouMC[line].over *wMC,
      under:ouAn[line].under*wAN + ouMC[line].under*wMC
    };
  });

  return {
    simCount,
    pH,pD,pA,
    avgGoals,
    matrix,
    scoreCap,
    ou,
    god:{
      pattern: pat,
      hyperLambda:{lamH:lamH_base, lamA:lamA_base}
    },
    scenarioStats:{
      scenarios:scenarios.map(s=>({name:s.name,p:s.p})),
      count:scenarioCount,
      phases:phaseList
    }
  };
};

// -------------------------------------------------------------
// Deterministic simulation (Poisson analytic)
// -------------------------------------------------------------
V20.detSim = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);

  let pH=0, pD=0, pA=0;
  const maxG = 8;

  const ou = {
    "0.5":{over:0,under:0},
    "1.5":{over:0,under:0},
    "2.5":{over:0,under:0},
    "3.5":{over:0,under:0}
  };

  let total=0;

  for (let h=0; h<=maxG; h++){
    const pPH = V20.poissonPMF(lamH,h);
    for (let a=0; a<=maxG; a++){
      const pPA = V20.poissonPMF(lamA,a);
      const p   = pPH*pPA;
      total += p;

      if(h>a)      pH += p;
      else if(h===a)pD += p;
      else          pA += p;

      const sum = h+a;
      if(sum>0) ou["0.5"].over += p; else ou["0.5"].under += p;
      if(sum>1) ou["1.5"].over += p; else ou["1.5"].under += p;
      if(sum>2) ou["2.5"].over += p; else ou["2.5"].under += p;
      if(sum>3) ou["3.5"].over += p; else ou["3.5"].under += p;
    }
  }

  if(total>0){
    pH/=total; pD/=total; pA/=total;
    Object.values(ou).forEach(o=>{
      o.over /= total; o.under /= total;
    });
  }

  return {pH,pD,pA,ou};
};

// -------------------------------------------------------------
// Chaos model — adjust λ with chaos factor
// -------------------------------------------------------------
V20.chaosModel = function(lambda, ctx){
  lambda = lambda || {};
  ctx    = ctx || {};

  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);
  const chaos = ctx.chaos || 5;
  const chaosF = (chaos - 5)/5;

  const factor = 1 + V20.clamp(chaosF*0.24, -0.24, 0.36);

  return {
    lamH: V20.clamp(lamH*factor, 0.20, 6.00),
    lamA: V20.clamp(lamA*factor, 0.20, 6.00)
  };
};

// =============================================================
// PART 3 SELESAI
// Selanjutnya PART 4:
// • Risk, Fragility, SDI
// • Meta Consistency
// • Flow Model
// • Momentum Swing
// • Singularity Layer
// • Prime Index
// • Fusing Models
// =============================================================
</script>
<script>
// =============================================================
// PART 4 — Risk, Fragility, SDI, Meta, Flow + PRIME SINGULARITY ZERO
// =============================================================

// -------------------------------------------------------------
// Risiko total berdasarkan chaos, tempo, fleksibilitas
// -------------------------------------------------------------
V20.computeRisk = function(ctx, tact){
  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;
  const flexAvg = (flexH + flexA) / 2;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;

  let risk = 0.42
           + chaosF*0.33
           + tempoF*0.18
           + flexAvg*0.20;

  return V20.clamp(risk, 0, 1);
};

// -------------------------------------------------------------
// Fragility = seberapa mudah perubahan hasil terjadi
// -------------------------------------------------------------
V20.computeFragility = function(ctx, home, away){
  const chaos = ctx.chaos || 5;
  const stH = home.stability || 5;
  const stA = away.stability || 5;

  const stabAvg = (stH + stA) / 2;
  const chaosF  = (chaos - 5)/5;
  const stabF   = (stabAvg - 5)/5;

  let frag = 0.40
            + chaosF*0.30
            - stabF*0.25;

  return V20.clamp(frag, 0, 1);
};

// -------------------------------------------------------------
// SDI — Score Direction Index
// arah kecenderungan skor
// -------------------------------------------------------------
V20.computeSDI = function(lambda){
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);
  const gap = lamH - lamA;

  return V20.clamp(gap/2.5, -1, 1);
};

// -------------------------------------------------------------
// Meta Consistency — Konsistensi lintas model
// -------------------------------------------------------------
V20.computeMeta = function(det, chaosM, sdi){
  const detGap   = det.pH - det.pA;
  const chaosGap = chaosM.pH - chaosM.pA;

  let meta = 1 - (Math.abs(detGap - chaosGap)*0.45
                + Math.abs(sdi)*0.20);

  return V20.clamp(meta, 0, 1);
};

// -------------------------------------------------------------
// FLOW Model — momentum + press + pattern
// -------------------------------------------------------------
V20.computeFlow = function(ctx, home, away, tact, pat){
  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const mg = momH - momA;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;
  const pg = pressH - pressA;

  let flow = mg*0.10 + pg*0.08;

  flow += (pat.swing*0.10 + pat.chaotic*0.06) * (mg/7);

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  flow += chaosF*0.05 + tempoF*0.03;

  return V20.clamp(flow, -1, 1);
};

// -------------------------------------------------------------
// Momentum Swing — perubahan tren
// -------------------------------------------------------------
V20.computeMomentumSwing = function(home, away){
  const mH = home.momentum || 5;
  const mA = away.momentum || 5;

  const base = (mH - mA)/10;
  return V20.clamp(base*1.1, -1, 1);
};

// -------------------------------------------------------------
// PRIME SINGULARITY ZERO — final correction layer
// -------------------------------------------------------------
V20.singularityZero = function(raw, risk, frag, meta, flow, swing){
  let pH = raw.pH;
  let pD = raw.pD;
  let pA = raw.pA;

  const riskF = risk;
  const fragF = frag;
  const metaF = meta;

  const lowMeta  = 1 - metaF;
  const highRisk = riskF;
  const highFrag = fragF;

  const compress = 0.50 + lowMeta*0.35 + highRisk*0.30 + highFrag*0.30;
  const comp = V20.clamp(compress, 0, 0.99);

  let center = (pH + pA)/2;
  pH = center + (pH-center)*(1-comp);
  pA = center + (pA-center)*(1-comp);

  pH *= (1 + flow*0.14 + swing*0.10);
  pA *= (1 - flow*0.14 - swing*0.10);

  const floor = 0.06;
  const addD  = (Math.abs(pH - pA))*0.22;
  pD += addD;

  pH = Math.max(pH - pD*0.10, floor);
  pA = Math.max(pA - pD*0.10, floor);
  pD = Math.max(pD, floor);

  let sum = pH + pD + pA;
  if(sum === 0){
    pH = pD = pA = 1/3;
  } else {
    pH /= sum; pD /= sum; pA /= sum;
  }

  if(flow > 0 && swing > 0){
    pH *= (1 + 0.07*flow + 0.05*swing);
    pA *= (1 - 0.07*flow - 0.05*swing);
  }
  else if(flow < 0 && swing < 0){
    pA *= (1 + 0.07*(-flow) + 0.05*(-swing));
    pH *= (1 - 0.07*(-flow) - 0.05*(-swing));
  }

  let s2 = pH + pD + pA;
  if(s2 === 0){
    pH = pD = pA = 1/3;
  } else {
    pH /= s2; pD /= s2; pA /= s2;
  }

  return {pH,pD,pA};
};

// -------------------------------------------------------------
// FUSION OUTPUT (Final 1X2)
// -------------------------------------------------------------
V20.fuseOutputs = function(det, chaosM, mc, zero){
  return {
    raw:{
      deterministic:det,
      chaos:chaosM,
      mc:mc
    },
    final:{
      pH:zero.pH,
      pD:zero.pD,
      pA:zero.pA
    }
  };
};

// =============================================================
// PART 4 SELESAI
// Selanjutnya PART 5:
// • AUTO-CALC fungsi lengkap
// • ENGINE RUNNER
// • OUTPUT generator
// • Penutup HTML
// =============================================================
</script>
<script>
// =============================================================
// PART 5 — AUTO-CALC + ENGINE RUNNER + OUTPUT
// =============================================================

// -------------------------------------------------------------
// AUTO-CALC INPUT WAJIB (ADVANCED MODE)
// Mengisi otomatis: λH, λA, Momentum, Stability, Press, Flex
// -------------------------------------------------------------
V20.autoCalcRequired = function(){
  const outEl = document.getElementById('output');

  // baca advanced stats
  const xgH   = V20.num(document.getElementById('adv_xg_home').value, NaN);
  const xgA   = V20.num(document.getElementById('adv_xg_away').value, NaN);
  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);

  const fHw = V20.num(document.getElementById('adv_form_home_w').value, 0);
  const fHd = V20.num(document.getElementById('adv_form_home_d').value, 0);
  const fHl = V20.num(document.getElementById('adv_form_home_l').value, 0);

  const fAw = V20.num(document.getElementById('adv_form_away_w').value, 0);
  const fAd = V20.num(document.getElementById('adv_form_away_d').value, 0);
  const fAl = V20.num(document.getElementById('adv_form_away_l').value, 0);

  const ppdaH = V20.num(document.getElementById('adv_ppda_home').value, NaN);
  const ppdaA = V20.num(document.getElementById('adv_ppda_away').value, NaN);

  const errH  = V20.num(document.getElementById('adv_err_home').value, 0);
  const errA  = V20.num(document.getElementById('adv_err_away').value, 0);

  const formH = V20.num(document.getElementById('adv_formasi_home').value, 1);
  const formA = V20.num(document.getElementById('adv_formasi_away').value, 1);

  // ---- 1) λH & λA dari xG + xGA ----
  let lamH = 1.20;
  let lamA = 1.00;

  if (isFinite(xgH) && isFinite(xgaA)){
    lamH = 0.60 * xgH + 0.40 * xgaA;
  }
  if (isFinite(xgA) && isFinite(xgaH)){
    lamA = 0.60 * xgA + 0.40 * xgaH;
  }

  lamH = V20.clamp(lamH, 0.20, 4.50);
  lamA = V20.clamp(lamA, 0.20, 4.50);

  document.getElementById('lamH').value = lamH.toFixed(2);
  document.getElementById('lamA').value = lamA.toFixed(2);

  // ---- 2) Momentum (1–10) dari W/D/L ----
  function calcMomentum(W,D,L){
    const total = W+D+L;
    if (total <= 0) return 5;
    const rawScore = (3*W + 1*D - 2*L) / (3*5);  // kira-kira -? .. +1
    const norm = V20.clamp(0.5 + rawScore, 0, 1);
    return V20.clamp(1 + 9*norm, 1, 10);
  }

  const momH = calcMomentum(fHw,fHd,fHl);
  const momA = calcMomentum(fAw,fAd,fAl);

  document.getElementById('home_mom').value = momH.toFixed(1);
  document.getElementById('away_mom').value = momA.toFixed(1);

  // ---- 3) Stability (1–10) dari xGA + error ----
  function calcStability(xga, err){
    if (!isFinite(xga)) xga = 1.2;
    const base = 8.0 - (xga-1.0)*2.5 - err*1.2;
    return V20.clamp(base, 1, 10);
  }

  const stH = calcStability(xgaH, errH);
  const stA = calcStability(xgaA, errA);

  document.getElementById('home_st').value = stH.toFixed(1);
  document.getElementById('away_st').value = stA.toFixed(1);

  // ---- 4) Press Intensity (1–10) dari PPDA ----
  function calcPress(ppda){
    if (!isFinite(ppda)) return 5;
    // PPDA 4 → press ~9–10, PPDA 20 → press ~1–2
    const press = 11 - (ppda-4)*0.6;
    return V20.clamp(press, 1, 10);
  }

  const pressH = calcPress(ppdaH);
  const pressA = calcPress(ppdaA);

  document.getElementById('home_press').value = pressH.toFixed(1);
  document.getElementById('away_press').value = pressA.toFixed(1);

  // ---- 5) Flex (0–1) dari jumlah formasi aktif ----
  function calcFlex(formCount){
    if (formCount <= 1) return 0.20;
    if (formCount >= 3) return 0.80;
    return 0.50; // 2 formasi aktif
  }

  const flexH = calcFlex(formH);
  const flexA = calcFlex(formA);

  document.getElementById('home_flex').value = flexH.toFixed(2);
  document.getElementById('away_flex').value = flexA.toFixed(2);

  // Log singkat ke output
  if (outEl){
    let log = "";
    log += "[AUTO-CALC INPUT WAJIB — ADVANCED MODE]\n";
    log += `λH : ${lamH.toFixed(3)} | λA : ${lamA.toFixed(3)}\n`;
    log += `Momentum H/A : ${momH.toFixed(1)} / ${momA.toFixed(1)}\n`;
    log += `Stability H/A: ${stH.toFixed(1)} / ${stA.toFixed(1)}\n`;
    log += `Press H/A    : ${pressH.toFixed(1)} / ${pressA.toFixed(1)}\n`;
    log += `Flex H/A     : ${flexH.toFixed(2)} / ${flexA.toFixed(2)}\n\n`;
    outEl.value = log + (outEl.value || "");
  }

  alert("Auto-calc selesai. Input utama sudah terisi.");
};

// -------------------------------------------------------------
// Uncertainty (entropi 1X2)
// -------------------------------------------------------------
V20.computeUncertainty = function(pH,pD,pA){
  const probs = [pH,pD,pA];
  let entropy = 0;
  probs.forEach(p=>{
    if (p>0) entropy -= p*Math.log2(p);
  });
  const maxE = Math.log2(3);
  const norm = maxE>0 ? entropy/maxE : 0;
  return {
    entropy,
    norm,
    score: norm*100
  };
};

// -------------------------------------------------------------
// BTTS (Both Teams To Score) dari λ
// -------------------------------------------------------------
V20.computeBTTS = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.0001);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.0001);

  const pH0 = Math.exp(-lamH);
  const pA0 = Math.exp(-lamA);
  const p00 = Math.exp(-(lamH+lamA));

  const pBTTS = 1 - (pH0 + pA0 - p00);
  return V20.clamp(pBTTS, 0, 1);
};

// -------------------------------------------------------------
// PRIME SINGULARITY ZERO — ENGINE RUNNER
// -------------------------------------------------------------
V20.runPrimeZero = function(){
  const outEl = document.getElementById('output');
  if (!outEl) return;

  // --- BACA INPUT ---
  const lamH  = V20.num(document.getElementById('lamH').value, 1.20);
  const lamA  = V20.num(document.getElementById('lamA').value, 1.00);

  const tempo = V20.num(document.getElementById('tempo').value, 5);
  const chaos = V20.num(document.getElementById('chaos').value, 5);
  const importance = V20.num(document.getElementById('importance').value, 5);

  const home_st  = V20.num(document.getElementById('home_st').value, 5);
  const away_st  = V20.num(document.getElementById('away_st').value, 5);
  const home_mom = V20.num(document.getElementById('home_mom').value, 5);
  const away_mom = V20.num(document.getElementById('away_mom').value, 5);

  const home_press = V20.num(document.getElementById('home_press').value, 5);
  const away_press = V20.num(document.getElementById('away_press').value, 5);
  const home_flex  = V20.num(document.getElementById('home_flex').value, 0.5);
  const away_flex  = V20.num(document.getElementById('away_flex').value, 0.5);

  let simCount  = V20.num(document.getElementById('simCount').value, NaN);
  let scoreCap  = V20.num(document.getElementById('scoreCap').value, NaN);
  if (!isFinite(simCount)) simCount = undefined;
  if (!isFinite(scoreCap)) scoreCap = undefined;

  const lambda = { lamH, lamA };
  const ctx = { tempo, chaos, importance };
  const home = { stability: home_st, momentum: home_mom };
  const away = { stability: away_st, momentum: away_mom };
  const tact = {
    home: { pressIntensity: home_press, flex: home_flex },
    away: { pressIntensity: away_press, flex: away_flex }
  };

  // --- MODEL INTI ---
  const det = V20.detSim(lambda);
  const chaosLambda = V20.chaosModel(lambda, ctx);
  const detChaos    = V20.detSim(chaosLambda);
  const mc          = V20.monteCarlo(lambda, ctx, simCount, scoreCap, home, away, tact);

  const godHL  = mc.god && mc.god.hyperLambda ? mc.god.hyperLambda : {lamH,lamA};
  const godPat = mc.god && mc.god.pattern ? mc.god.pattern : null;

  // baseline probabilitas 1X2 (gabungan det + chaos + MC)
  const base = {
    pH: (det.pH + detChaos.pH + mc.pH)/3,
    pD: (det.pD + detChaos.pD + mc.pD)/3,
    pA: (det.pA + detChaos.pA + mc.pA)/3
  };

  // --- METRIK LANJUTAN ---
  const risk01  = V20.computeRisk(ctx, tact);
  const frag01  = V20.computeFragility(ctx, home, away);
  const sdi     = V20.computeSDI(godHL);
  const meta01  = V20.computeMeta(det, detChaos, sdi);
  const flowVal = V20.computeFlow(ctx, home, away, tact, godPat || {control:0.25,swing:0.25,stalled:0.25,chaotic:0.25});
  const swingVal= V20.computeMomentumSwing(home, away);

  const zeroProb = V20.singularityZero(
    base,
    risk01,
    frag01,
    meta01,
    flowVal,
    swingVal
  );

  const fused = V20.fuseOutputs(det, detChaos, mc, zeroProb);

  const unc   = V20.computeUncertainty(fused.final.pH, fused.final.pD, fused.final.pA);
  const btts  = V20.computeBTTS(godHL);

  // risk/frag/meta ke skala 0–100
  const riskScore = risk01*100;
  const fragScore = frag01*100;
  const metaScore = meta01*100;

  // ENGINE STATUS sederhana
  let engineStatus = "PRIME STABLE";
  if (metaScore < 40 || riskScore > 70 || fragScore > 70){
    engineStatus = "PRIME CAUTION";
  } else if (metaScore < 60){
    engineStatus = "PRIME NEUTRAL";
  }

  // --- SUSUN OUTPUT ---
  let text = "";
  text += "=== MATCH SIMULATION REPORT — PRIME SINGULARITY ZERO ∑.0 ===\n\n";

  text += "[ENGINE TIER]\n";
  text += "Core    : Pattern Oracle + Hyper Lambda + MC + Singularity Zero\n";
  text += `Status  : ${engineStatus}\n\n`;

  text += "[INPUT]\n";
  text += `λH (input) : ${lamH.toFixed(3)}\n`;
  text += `λA (input) : ${lamA.toFixed(3)}\n`;
  text += `Tempo       : ${tempo.toFixed(1)}\n`;
  text += `Chaos       : ${chaos.toFixed(1)}\n`;
  text += `Importance  : ${importance.toFixed(1)}\n`;
  text += `Home Stab   : ${home_st.toFixed(1)} | Mom: ${home_mom.toFixed(1)}\n`;
  text += `Away Stab   : ${away_st.toFixed(1)} | Mom: ${away_mom.toFixed(1)}\n`;
  text += `Press H/A   : ${home_press.toFixed(1)} / ${away_press.toFixed(1)}\n`;
  text += `Flex  H/A   : ${home_flex.toFixed(2)} / ${away_flex.toFixed(2)}\n`;
  text += `SimCount    : ${mc.simCount}\n`;
  text += `Score Cap   : ${mc.scoreCap}\n\n`;

  text += "[GOD HYPER LAMBDA]\n";
  text += `λH (Hyper) : ${godHL.lamH.toFixed(3)}\n`;
  text += `λA (Hyper) : ${godHL.lamA.toFixed(3)}\n\n`;

  text += "[PATTERN ORACLE]\n";
  let domPattern = "N/A";
  if (godPat){
    text += `Control : ${(godPat.control*100).toFixed(1)}%\n`;
    text += `Swing   : ${(godPat.swing*100).toFixed(1)}%\n`;
    text += `Stalled : ${(godPat.stalled*100).toFixed(1)}%\n`;
    text += `Chaotic : ${(godPat.chaotic*100).toFixed(1)}%\n`;
    domPattern = "control";
    let best = godPat.control;
    if (godPat.swing   > best){ domPattern="swing";   best=godPat.swing; }
    if (godPat.stalled > best){ domPattern="stalled"; best=godPat.stalled; }
    if (godPat.chaotic > best){ domPattern="chaotic"; best=godPat.chaotic; }
  } else {
    text += "Pattern data tidak tersedia.\n";
  }
  text += `Dominant Pattern : ${domPattern.toUpperCase()}\n\n`;

  text += "[1X2 PROBABILITIES — PRIME SINGULARITY ZERO]\n";
  text += `Home Win : ${(fused.final.pH*100).toFixed(1)}%\n`;
  text += `Draw     : ${(fused.final.pD*100).toFixed(1)}%\n`;
  text += `Away Win : ${(fused.final.pA*100).toFixed(1)}%\n\n`;

  text += "[RISK / FRAGILITY / META / UNCERTAINTY]\n";
  text += `Risk Index        : ${riskScore.toFixed(1)} / 100\n`;
  text += `Fragility Index   : ${fragScore.toFixed(1)} / 100\n`;
  text += `Meta-Consistency  : ${metaScore.toFixed(1)} / 100\n`;
  text += `Uncertainty (1X2) : ${unc.score.toFixed(1)} / 100\n`;
  text += `Flow Value        : ${flowVal.toFixed(3)} (H+ vs A-)\n`;
  text += `Momentum Swing    : ${swingVal.toFixed(3)}\n\n`;

  text += "[GOAL MODEL]\n";
  text += `Avg Goals (MC)    : ${mc.avgGoals.toFixed(3)}\n`;
  text += `BTTS (kedua tim gol) : ${(btts*100).toFixed(1)}%\n\n`;

  text += "[OVER/UNDER (Blend MC + Analytic)]\n";
  const ou = mc.ou || {};
  ["0.5","1.5","2.5","3.5"].forEach(k=>{
    const o = ou[k] || {over:0,under:0};
    text += `O/U ${k}  -> Over: ${(o.over*100).toFixed(1)}% | Under: ${(o.under*100).toFixed(1)}%\n`;
  });
  text += "\n";

  text += "[SCENARIO DISTRIBUTION]\n";
  if (mc.scenarioStats && mc.scenarioStats.scenarios){
    mc.scenarioStats.scenarios.forEach(s=>{
      text += `${s.name.padEnd(10," ")} : ${(s.p*100).toFixed(1)}%\n`;
    });
  }
  text += "\n";

  text += "[SCORE MATRIX] (frekuensi relatif simulasi)\n";
  const mat = mc.matrix;
  const cap = mc.scoreCap;

  text += "     ";
  for(let a=0;a<=cap;a++){
    text += `A${a}    `;
  }
  text += "\n";

  for(let h=0;h<=cap;h++){
    text += `H${h}  `;
    for(let a=0;a<=cap;a++){
      const v = (mat[h] && mat[h][a]) ? mat[h][a]/mc.simCount : 0;
      text += v.toFixed(3).padEnd(7," ");
    }
    text += "\n";
  }

  outEl.value = text;
};

// -------------------------------------------------------------
// EVENT LISTENER TOMBOL
// -------------------------------------------------------------
window.addEventListener('DOMContentLoaded', function(){
  const btnAnalyze = document.getElementById('btn_analyze');
  if (btnAnalyze){
    btnAnalyze.addEventListener('click', function(){
      try {
        V20.runPrimeZero();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat menjalankan PRIME SINGULARITY ZERO. Cek console.");
      }
    });
  }

  const btnAuto = document.getElementById('btn_auto_calc');
  if (btnAuto){
    btnAuto.addEventListener('click', function(){
      try {
        V20.autoCalcRequired();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat AUTO-CALC. Cek console & input advanced.");
      }
    });
  }
});

// =============================================================
// PART 5 SELESAI — PRIME SINGULARITY ZERO ∑.0 ENGINE COMPLETE
// =============================================================
</script>

</body>
</html>
