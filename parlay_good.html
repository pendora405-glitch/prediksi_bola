<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Match Simulation Engine — PRIME SINGULARITY ZERO ∑.REBUILD</title>

<style>
:root{
  --bg:#02030a;
  --bg-panel:#070a16;
  --accent:#12e4ff;
  --accent-soft:#12b8e3;
  --accent-2:#7bffb5;
  --border:#232843;
  --text:#f5f7ff;
  --muted:#8f95c7;
  --danger:#ff4f81;
}

*{
  box-sizing:border-box;
}

body{
  margin:0;
  padding:24px;
  background:
    radial-gradient(circle at top,#142042 0,#02030a 55%,#000 100%);
  color:var(--text);
  font-family:"Segoe UI",system-ui,-apple-system,Arial,sans-serif;
}

/* TITLE FUTURISTIC */
h1{
  font-size:26px;
  margin:0 0 18px;
  text-transform:uppercase;
  letter-spacing:0.12em;
  color:var(--accent);
  text-shadow:
    0 0 18px rgba(18,228,255,.8),
    0 0 40px rgba(0,0,0,.9);
}

/* SUBHEADER */
h2{
  font-size:15px;
  margin:0 0 10px;
  letter-spacing:.06em;
  text-transform:uppercase;
  color:#e5e9ff;
}

h3{
  font-size:13px;
  margin:8px 0 6px;
  color:var(--muted);
  text-transform:uppercase;
  letter-spacing:.08em;
}

/* PANEL / SECTION HOLOGRAM */
.section{
  padding:12px 14px 14px;
  margin:0 0 14px;
  border-radius:12px;
  border:1px solid rgba(74,98,210,.7);
  background:
    linear-gradient(145deg,rgba(9,13,35,.96),rgba(5,9,24,.96));
  box-shadow:
    0 0 22px rgba(4,255,214,.12),
    0 0 60px rgba(0,0,0,.8);
  backdrop-filter:blur(18px);
}

/* LABEL */
label{
  display:block;
  margin-top:7px;
  font-size:12px;
  color:var(--muted);
}

/* INPUT FUTURISTIC */
input,
select{
  width:100%;
  margin-top:4px;
  padding:7px 9px;
  border-radius:8px;
  border:1px solid rgba(86,102,160,.9);
  background:
    radial-gradient(circle at top,rgba(34,42,92,.9),rgba(8,11,32,.98));
  color:var(--text);
  font-size:12px;
  outline:none;
  transition:
    border .16s ease,
    box-shadow .16s ease,
    background .16s ease;
}

input:focus,
select:focus{
  border-color:var(--accent);
  box-shadow:
    0 0 0 1px rgba(18,228,255,.3),
    0 0 18px rgba(0,255,204,.25);
}

input::placeholder{
  color:rgba(160,168,220,.65);
}

/* TOMBOL NEON */
button{
  display:inline-block;
  margin-top:10px;
  margin-right:6px;
  margin-bottom:4px;
  padding:8px 12px;
  border-radius:999px;
  border:none;
  background:linear-gradient(135deg,var(--accent-soft),var(--accent));
  color:#000;
  font-size:11px;
  font-weight:700;
  letter-spacing:.08em;
  text-transform:uppercase;
  cursor:pointer;
  box-shadow:0 0 16px rgba(18,228,255,.6);
  transition:
    transform .12s ease,
    box-shadow .12s ease,
    filter .12s ease;
}

button:hover{
  transform:translateY(-1px) scale(1.01);
  box-shadow:0 0 22px rgba(18,228,255,.9);
  filter:brightness(1.05);
}

button:active{
  transform:translateY(0) scale(.99);
  box-shadow:0 0 10px rgba(18,228,255,.6);
}

/* OUTPUT TERMINAL */
textarea{
  width:100%;
  height:360px;
  margin-top:10px;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid rgba(60,80,150,.9);
  background:#02030a;
  color:#38ff9c;
  font-family:"JetBrains Mono","Fira Code",monospace;
  font-size:11px;
  line-height:1.32;
  white-space:pre;
  box-shadow:0 0 14px rgba(0,255,153,.3);
}

/* INFO KECIL */
small{
  display:block;
  margin-top:3px;
  font-size:11px;
  color:var(--muted);
}

/* TRIPLE INPUT (sudah ada di script lama) */
.triple-input{
  display:flex;
  gap:6px;
  margin-top:4px;
}
.triple-input input{
  width:33.33%;
}

/* GARIS PEMISAH */
hr.line{
  margin:12px 0;
  border:0;
  border-top:1px dashed rgba(70,96,175,.9);
}

/* BADGE MANUAL / AUTO (opsional jika mau dipakai) */
.badge-row{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  margin-bottom:10px;
}
.badge{
  padding:4px 8px;
  border-radius:999px;
  border:1px solid rgba(120,140,255,.6);
  font-size:10px;
  letter-spacing:.09em;
  text-transform:uppercase;
  color:var(--muted);
  background:radial-gradient(circle at top,rgba(43,55,120,.9),rgba(8,11,26,1));
}
.badge--manual{
  border-color:#ff9f4f;
  color:#ffd6a0;
}
.badge--auto{
  border-color:#4dffb5;
  color:#b6ffdf;
}

/* OPSIONAL: layout 2 kolom kalau nanti mau dibungkus .layout, .layout-main, .layout-side */
@media (min-width:980px){
  body{
    padding:26px 40px;
  }
  .layout{
    display:grid;
    grid-template-columns:minmax(0,1.4fr) minmax(0,1fr);
    gap:18px;
    align-items:flex-start;
  }
  .layout-main{
    display:flex;
    flex-direction:column;
    gap:14px;
  }
  .layout-side{
    position:sticky;
    top:18px;
  }
}

@media (max-width:979px){
  .layout-main,
  .layout-side{
    margin-bottom:10px;
  }
}
</style>
</head>

<body>

<h1>Match Simulation Engine — PRIME SINGULARITY ZERO ∑.REBUILD</h1>

<!-- =========================
     INPUT STATISTIK UTAMA
========================= -->
<div class="section">
  <h2>Input Statistik Utama</h2>

  <label>Expected Goals Home (λH)</label>
  <input id="lamH" type="number" min="0.1" max="5" step="0.05" placeholder="mis: 1.60">

  <label>Expected Goals Away (λA)</label>
  <input id="lamA" type="number" min="0.1" max="5" step="0.05" placeholder="mis: 1.20">

  <label>Tempo (1–10) <small>(kecepatan ritme pertandingan)</small></label>
  <input id="tempo" type="number" min="1" max="10" placeholder="5">

  <label>Chaos (1–10) <small>(seberapa liar / tidak terstruktur)</small></label>
  <input id="chaos" type="number" min="1" max="10" placeholder="5">

  <label>Importance (1–10) <small>(seberapa penting match: final, derby, dll.)</small></label>
  <input id="importance" type="number" min="1" max="10" placeholder="5">
</div>

<!-- =========================
     DATA TIM
========================= -->
<div class="section">
  <h2>Data Tim</h2>

  <label>Home Stability (1–10) <small>(soliditas & konsistensi pertahanan)</small></label>
  <input id="home_st" type="number" min="1" max="10" placeholder="5">

  <label>Away Stability (1–10)</label>
  <input id="away_st" type="number" min="1" max="10" placeholder="5">

  <label>Home Momentum (1–10) <small>(form & mental sekarang)</small></label>
  <input id="home_mom" type="number" min="1" max="10" placeholder="5">

  <label>Away Momentum (1–10)</label>
  <input id="away_mom" type="number" min="1" max="10" placeholder="5">
</div>

<!-- =========================
     TAKTIK & FLEKSIBILITAS
========================= -->
<div class="section">
  <h2>Taktik & Fleksibilitas</h2>

  <label>Home Press Intensity (1–10)</label>
  <input id="home_press" type="number" min="1" max="10" placeholder="5">

  <label>Away Press Intensity (1–10)</label>
  <input id="away_press" type="number" min="1" max="10" placeholder="5">

  <label>Home Flex (0–1) <small>(0 = formasi kaku, 1 = sangat fleksibel)</small></label>
  <input id="home_flex" type="number" min="0" max="1" step="0.05" placeholder="0.5">

  <label>Away Flex (0–1)</label>
  <input id="away_flex" type="number" min="0" max="1" step="0.05" placeholder="0.5">

  <small>
    Jika tim hanya memakai 1 formasi & jarang berubah, flex sekitar 0.10–0.30.  
    Jika sering ganti formasi (2–3 variasi), flex 0.50–0.80.
  </small>
</div>

<!-- =========================
     ADVANCED STATS + AUTO-CALC INPUT WAJIB
========================= -->
<div class="section">
  <h2>Advanced Stats (Auto-Calc Input Wajib)</h2>

  <label>xG Home (rata-rata 5 laga terakhir)</label>
  <input id="adv_xg_home" type="number" step="0.01" placeholder="mis: 1.70">

  <label>xG Away (rata-rata 5 laga terakhir)</label>
  <input id="adv_xg_away" type="number" step="0.01" placeholder="mis: 1.30">

  <label>xGA Home (rata-rata xG kebobolan per laga)</label>
  <input id="adv_xga_home" type="number" step="0.01" placeholder="mis: 1.10">

  <label>xGA Away (rata-rata xG kebobolan per laga)</label>
  <input id="adv_xga_away" type="number" step="0.01" placeholder="mis: 1.40">

  <label>Form Home (W-D-L, 5 laga terakhir)</label>
  <div class="triple-input">
    <input id="adv_form_home_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_home_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_home_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>Form Away (W-D-L, 5 laga terakhir)</label>
  <div class="triple-input">
    <input id="adv_form_away_w" type="number" min="0" max="5" placeholder="W">
    <input id="adv_form_away_d" type="number" min="0" max="5" placeholder="D">
    <input id="adv_form_away_l" type="number" min="0" max="5" placeholder="L">
  </div>

  <label>PPDA Home (rata-rata, makin rendah = press tinggi)</label>
  <input id="adv_ppda_home" type="number" step="0.1" placeholder="mis: 8.0">

  <label>PPDA Away</label>
  <input id="adv_ppda_away" type="number" step="0.1" placeholder="mis: 10.5">
<label>Gaya Pressing Home (jika tidak ada PPDA asli)</label>
  <select id="press_style_home">
    <option value="">-- Pilih gaya pressing --</option>
    <option value="high">High Press (mengejar tinggi)</option>
    <option value="mid_high">Mid–High Press</option>
    <option value="mid">Mid Block (seimbang)</option>
    <option value="mid_low">Mid–Low Block</option>
    <option value="low">Low Block / sangat pasif</option>
    <option value="extreme_high">Extreme High Press</option>
<option value="gegenpress">Gegenpress</option>
<option value="hybrid_press">Hybrid Press</option>
<option value="deep_low">Deep Low Block</option>

<option value="man_marking_high">Man-Marking High Press</option>
<option value="positional_high">Positional High Press</option>
<option value="semi_gegenpress">Semi-Gegenpress</option>
<option value="reactive_press">Reactive Press</option>
<option value="wing_press">Wing Press Trap</option>
<option value="inverted_press">Inverted Press</option>
<option value="zonal_midlow">Zonal Mid-Low Block</option>
<option value="ultra_compact">Ultra Compact Block</option>
    <option value="box-press">Box Midfield Press</option>
<option value="diamond-press">Diamond Stagger Press</option>
<option value="lanepress-wide">Wide Lane Trap Press</option>
<option value="lanepress-narrow">Narrow Lane Isolation Press</option>
<option value="halfspace-press">Halfspace Pressure System</option>
<option value="rest-defense-high">Rest Defense High Press</option>
  </select>
  
  
  <label>Gaya Pressing Away (jika tidak ada PPDA asli)</label>
  <select id="press_style_away">
    <option value="">-- Pilih gaya pressing --</option>
    <option value="high">High Press (mengejar tinggi)</option>
    <option value="mid_high">Mid–High Press</option>
    <option value="mid">Mid Block (seimbang)</option>
    <option value="mid_low">Mid–Low Block</option>
    <option value="low">Low Block / sangat pasif</option>
    <option value="extreme_high">Extreme High Press</option>
<option value="gegenpress">Gegenpress</option>
<option value="hybrid_press">Hybrid Press</option>
<option value="deep_low">Deep Low Block</option>
<option value="man_marking_high">Man-Marking High Press</option>
<option value="positional_high">Positional High Press</option>
<option value="semi_gegenpress">Semi-Gegenpress</option>
<option value="reactive_press">Reactive Press</option>
<option value="wing_press">Wing Press Trap</option>
<option value="inverted_press">Inverted Press</option>
<option value="zonal_midlow">Zonal Mid-Low Block</option>
<option value="ultra_compact">Ultra Compact Block</option>
    <option value="box-press">Box Midfield Press</option>
<option value="diamond-press">Diamond Stagger Press</option>
<option value="lanepress-wide">Wide Lane Trap Press</option>
<option value="lanepress-narrow">Narrow Lane Isolation Press</option>
<option value="halfspace-press">Halfspace Pressure System</option>
<option value="rest-defense-high">Rest Defense High Press</option>
</select>

  <button onclick="applyPressingFullSystem()">PRESSING FULL SYSTEM</button>
  <button onclick="autoPPDA_Extended()">AUTO PRESSING → PPDA EXTENDED</button>
  <button onclick="showPressDuel()">PRESS DUEL INDEX</button>
  <button onclick="autoFlex()">AUTO FLEX</button>
  <button onclick="pressHeatmap()">PRESS HEATMAP</button>
  <button onclick="analysisSummary()">MATCH SUMMARY</button>
  <button onclick="FATE_runFateCollapse()">FATE COLLAPSE ENGINE</button>
<button onclick="GUN_runGrandUnified()">GRAND UNIFIED ENGINE</button>
  <button onclick="QRE_runQuantumReality()">QUANTUM REALITY ENGINE</button>
<button onclick="MNE_runMetaNarrative()">META NARRATIVE ENGINE</button>
<button onclick="AIF_runFormationAI()">AI FORMATION ADAPTATION</button>
<button onclick="UIE_runUnitedIntelligence()">UNITED INTELLIGENCE ENGINE</button>
  <button onclick="HRE_runHyperReality()">HYPER-REALITY ENGINE</button>
<button onclick="GOE_runGeneticOutcome()">GENETIC OUTCOME ENGINE</button>
<button onclick="CFM_runChaosFractal()">CHAOS FRACTAL MODEL</button>
<button onclick="DPAI_runDeepPatternAI()">DEEP PATTERN AI</button>
<button onclick="FSE_runFieldShape()">FIELD SHAPE ENGINE</button>
<button onclick="FTF_runFutureTrend()">FUTURE TREND FORECASTER</button>
<button onclick="AMI_runMarketIntel()">MARKET INTELLIGENCE (MODEL)</button>
<button onclick="MEO_runMetaOrchestrator()">META ENGINE ORCHESTRATOR</button>
  <small>
    Gunakan jika situs tidak menyediakan angka PPDA.  
    Estimasi dibuat dari gaya pressing + xGA + error defensif.  
    Hasilnya otomatis mengisi PPDA Home/Away di atas.
  </small>
  
  <label>Error Defensif Home per laga (perkiraan)</label>
  <input id="adv_err_home" type="number" step="0.1" placeholder="mis: 0.8">

  <label>Error Defensif Away per laga</label>
  <input id="adv_err_away" type="number" step="0.1" placeholder="mis: 1.2">

  <label>Jumlah Formasi Aktif Home (1–3)</label>
  <input id="adv_formasi_home" type="number" min="1" max="3" placeholder="mis: 2">

  <label>Jumlah Formasi Aktif Away (1–3)</label>
  <input id="adv_formasi_away" type="number" min="1" max="3" placeholder="mis: 1">

  <button id="btn_auto_calc">AUTO-CALC INPUT WAJIB</button>
  <small>
    Mengisi otomatis: λH, λA, Momentum, Stability, Press, dan Flex  
    berdasarkan data advanced di atas.
  </small>

  <hr class="line">

  <h3>Auto-Fill Tempo / Chaos / Importance</h3>

  <label>Jenis Laga (Match Type)</label>
  <select id="auto_match_type">
    <option value="">-- Pilih jenis laga --</option>
    <option value="friendly">Friendly / tidak penting</option>
    <option value="league_normal">Liga biasa</option>
    <option value="big_match">Big match / zona Eropa</option>
    <option value="derby">Derby / tensi tinggi</option>
    <option value="final">Final / hidup-mati / degradasi</option>
  </select>

  <label>Perkiraan Gaya Pertandingan</label>
  <select id="auto_match_style">
    <option value="">-- Pilih gaya --</option>
    <option value="slow_structured">Lambat & terstruktur</option>
    <option value="balanced">Seimbang</option>
    <option value="fast_open">Cepat & cukup terbuka</option>
    <option value="wild">Sangat terbuka / liar</option>
  </select>

  <button id="btn_auto_tci">AUTO-FILL TEMPO / CHAOS / IMPORTANCE</button>
  <small>
    Menggunakan kombinasi xG, xGA, PPDA, error defensif, dan tipe laga  
    untuk mengisi Tempo, Chaos, dan Importance secara otomatis.  
    Nilai tetap bisa kamu edit manual setelah terisi.
  </small>
</div>
<!-- ============================
     PATCH UI – ELITE+ / MANAGER / GOAL FLOW
     ============================ -->

<h3>Match Context Elite+</h3>

<label>Referee Strictness (0 = longgar, 5 = sangat ketat)</label>
<input id="ref_strict" type="number" min="0" max="5" step="1">

<label>VAR Style</label>
<select id="var_style">
  <option value="normal">Normal</option>
  <option value="lenient">Cenderung Biarkan Main</option>
  <option value="strict">Sering Intervensi</option>
</select>

<label>Stadium Intensity / Crowd Pressure (0–5)</label>
<input id="stadium_intensity" type="number" min="0" max="5" step="1">

<h3>Manager Tactics</h3>

<label>Coach Risk Profile (0 = sangat konservatif, 5 = sangat berani)</label>
<input id="coach_risk" type="number" min="0" max="5" step="1">

<label>Likely Tactical Change Timing</label>
<select id="tactical_timing">
  <option value="none">Jarang ubah</option>
  <option value="early">Awal babak 2 (46–60)</option>
  <option value="mid">Menit 60–75</option>
  <option value="late">Menit 75+</option>
</select>

<label>Bench Impact (0 = bench lemah, 5 = bench sangat kuat)</label>
<input id="bench_impact" type="number" min="0" max="5" step="1">

<h3>Goal Flow Tools</h3>
  <button id="btn_auto_ppda_ext">AUTO PPDA EXTENDED</button>
<button type="button" onclick="applyAutoElitePlus()">AUTO ELITE+ ENV</button>
<button type="button" onclick="applyManagerTactics()">AUTO MANAGER TACTICS</button>
<button type="button" onclick="generateGoalFlowMap()">GOAL FLOW MAP</button>
  <button onclick="INF_runInfinity()">RUN INFINITY ENGINE</button>
  <button onclick="autoMatchDifficulty()">MATCH DIFFICULTY</button>
  <button onclick="autoPressToMatchStyle()">PRESS → MATCH STYLE</button>
  <button onclick="setPiecePower()">SET PIECE POWER</button>
  <button onclick="dynamicMatchFlow()">MATCH FLOW</button>
  <button onclick="teamTrend()">TEAM TREND</button>
  <button onclick="SINF_runInfiniteEngine()">SINGULARITY ∞ ENGINE</button>
<!-- =========================
     PARAMETER SIMULASI
========================= -->
<div class="section">
  <h2>Parameter Simulasi</h2>

  <label>SimCount (Default 50000)</label>
  <input id="simCount" type="number" min="5000" max="300000" placeholder="kosongkan untuk default">

  <label>Score Cap (3–8, default auto)</label>
  <input id="scoreCap" type="number" min="3" max="8" placeholder="kosongkan untuk auto">

  <button id="btn_analyze">ANALYZE PRIME SINGULARITY ZERO</button>
  <button onclick="OP_runOmegaPrime()">Ω OMEGA PRIME</button>
  <button onclick="V21_homeAwayContext()">HOME–AWAY CONTEXT</button>
<button onclick="V21_injuryImpact()">INJURY IMPACT</button>
<button onclick="V21_weatherImpact()">WEATHER IMPACT</button>
<button onclick="V21_matchStateSim()">MATCH STATES</button>
<button onclick="V21_teamIdentity()">TEAM IDENTITY</button>
<button onclick="V21_playerStrength()">PLAYER STRENGTH</button>
<button onclick="V21_refVarImpact()">REF & VAR IMPACT</button>
<button onclick="V21_runSuite()">RUN SUITE</button>
  <hr class="line">
<h3>BRM & PARLAY TOOLS</h3>
<button onclick="BRM_runBankrollAdvisor()">BRM BANKROLL</button>
<button onclick="BRM_runParlayHelper()">PARLAY HELPER</button>
<button onclick="BRM_runEdgeClassifier()">EDGE CLASSIFIER</button>
<button onclick="BRM_runParlaySuite()">RUN BRM SUITE</button>
</div>

<!-- =========================
     OUTPUT
========================= -->
<div class="section">
  <h2>Output</h2>
  <textarea id="output" readonly></textarea>
</div>

<!-- SCRIPT PARTS AKAN DITEMPEL DI BAWAH INI (PART 2–5) -->
  <script>
// =============================================================
// PART 2 — NAMESPACE + UTILITY + POISSON CORE
// =============================================================

// Semua fungsi engine disimpan di namespace V20
const V20 = {};

// ---------------------------
// Number parsing aman
// ---------------------------
V20.num = function(v, fallback = 0){
  const n = Number(v);
  return isFinite(n) ? n : fallback;
};

// ---------------------------
// Clamp helper
// ---------------------------
V20.clamp = function(value, min, max){
  if (value < min) return min;
  if (value > max) return max;
  return value;
};

// ---------------------------
// Log factorial cache
// ---------------------------
V20._logFactorialCache = [0];
V20._logFactorial = function(n){
  const cache = V20._logFactorialCache;
  if (cache[n] != null) return cache[n];

  let val = cache[cache.length - 1];
  for (let i = cache.length; i <= n; i++){
    val += Math.log(i);
    cache[i] = val;
  }
  return cache[n];
};

// ---------------------------
// Poisson PMF — P(X = k)
// ---------------------------
V20.poissonPMF = function(lambda, k){
  lambda = Math.max(lambda, 0.00001);
  if (k < 0) return 0;
  return Math.exp(-lambda + k*Math.log(lambda) - V20._logFactorial(k));
};

// ---------------------------
// Poisson random sampler
// ---------------------------
V20.samplePoisson = function(lambda){
  lambda = Math.max(lambda, 0.00001);
  const L = Math.exp(-lambda);
  let p = 1, k = 0;
  do {
    p *= Math.random();
    k++;
  } while (p > L);
  return k - 1;
};

// ---------------------------
// Normalize array ke proporsi
// ---------------------------
V20.normalize = function(arr){
  let s = 0;
  for (let x of arr) s += x;
  if (!s) return arr.map(() => 1/arr.length);
  return arr.map(x => x/s);
};

// =============================================================
// PART 2 SELESAI
// Lanjut PART 3:
// • Pattern Oracle
// • Hyper Lambda (God Layer)
// • Monte Carlo Multi-Reality
// • Deterministic & Chaos Model
// =============================================================
  </script>
  <script>
// =============================================================
// PART 3 — PATTERN ORACLE + HYPER LAMBDA + MULTI-REALITY MC
// =============================================================


// -------------------------------------------------------------
// PATTERN ORACLE — menentukan pola pertandingan
// -------------------------------------------------------------
V20.patternOracle = function(ctx, home, away, tact){
  ctx  = ctx  || {};
  home = home || {stability:5, momentum:5};
  away = away || {stability:5, momentum:5};
  tact = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;
  const imp   = ctx.importance || 5;

  const stH = home.stability || 5;
  const stA = away.stability || 5;
  const stabAvg = (stH + stA)/2;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const momGap = momH - momA;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;
  const pressGap = pressH - pressA;

  const tempoF = (tempo - 5)/5;
  const chaosF = (chaos - 5)/5;
  const impF   = (imp   - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  let control = 0.35
              - chaosF*0.20
              + stabF*0.25
              + impF*0.05;

  let swing   = 0.25
              + Math.abs(momGap)*0.04
              + Math.abs(pressGap)*0.05
              + tempoF*0.15;

  let stalled = 0.15
              + (-tempoF)*0.20
              + stabF*0.15;

  let chaotic = 0.25
              + chaosF*0.35
              + tempoF*0.15
              - stabF*0.10;

  // clamp minimum
  control = Math.max(control, 0.01);
  swing   = Math.max(swing  , 0.01);
  stalled = Math.max(stalled, 0.01);
  chaotic = Math.max(chaotic, 0.01);

  // normalize
  let sum = control + swing + stalled + chaotic;
  const pattern = {
    control: control/sum,
    swing:   swing/sum,
    stalled: stalled/sum,
    chaotic: chaotic/sum
  };

  // dominant
  let dom = "control";
  let mx  = pattern.control;
  if(pattern.swing   > mx){ dom="swing";   mx=pattern.swing; }
  if(pattern.stalled > mx){ dom="stalled"; mx=pattern.stalled; }
  if(pattern.chaotic > mx){ dom="chaotic"; mx=pattern.chaotic; }

  return { pattern, dominant: dom };
};


// -------------------------------------------------------------
// HYPER LAMBDA — mengubah λ berdasarkan pola & taktik
// -------------------------------------------------------------
V20.hyperLambda = function(lambda, ctx, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  let lamH = V20.num(lambda.lamH, 1.2);
  let lamA = V20.num(lambda.lamA, 1.0);

  const tempo = ctx.tempo || 5;
  const chaos = ctx.chaos || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const stH  = home.stability || 5;
  const stA  = away.stability || 5;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;

  const momGap   = momH - momA;
  const pressGap = pressH - pressA;
  const stabAvg  = (stH + stA)/2;

  const PO  = V20.patternOracle(ctx, home, away, tact);
  const pat = PO.pattern;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const stabF  = (stabAvg - 5)/5;

  // Control → menahan sedikit output
  lamH *= (1 - pat.control*0.05);
  lamA *= (1 - pat.control*0.05);

  // Swing → efek momentum & pressing
  const swingH = pat.swing*(Math.max(0,momGap)/10 + Math.max(0,pressGap)/10);
  const swingA = pat.swing*(Math.max(0,-momGap)/10 + Math.max(0,-pressGap)/10);
  lamH *= (1 + swingH*0.22);
  lamA *= (1 + swingA*0.22);

  // Stalled → memperlambat
  lamH *= (1 - pat.stalled*0.10);
  lamA *= (1 - pat.stalled*0.10);

  // Chaotic → membuka peluang
  lamH *= (1 + pat.chaotic*0.25);
  lamA *= (1 + pat.chaotic*0.25);

  // Tekanan murni
  lamH *= (1 + (pressH-5)*0.015);
  lamA *= (1 + (pressA-5)*0.015);

  // Fleksibilitas
  lamH *= (1 + flexH*0.05);
  lamA *= (1 + flexA*0.05);

  // Chaos global
  lamH *= (1 + chaosF*0.10 + tempoF*0.02);
  lamA *= (1 + chaosF*0.10 + tempoF*0.02);

  lamH = V20.clamp(lamH, 0.20, 6.00);
  lamA = V20.clamp(lamA, 0.20, 6.00);

  return {
    lamH,
    lamA,
    pattern: pat,
    dominantPattern: PO.dominant
  };
};


// -------------------------------------------------------------
// DETERMINISTIC POISSON ANALYTIC
// -------------------------------------------------------------
V20.detSim = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);

  let pH=0, pD=0, pA=0;
  const maxG = 8;

  let ou = {
    "0.5":{over:0, under:0},
    "1.5":{over:0, under:0},
    "2.5":{over:0, under:0},
    "3.5":{over:0, under:0}
  };

  let total = 0;

  for (let h=0; h<=maxG; h++){
    let pPH = V20.poissonPMF(lamH, h);
    for (let a=0; a<=maxG; a++){
      let pPA = V20.poissonPMF(lamA, a);
      let p   = pPH*pPA;
      total += p;

      if(h > a)      pH += p;
      else if(h==a)  pD += p;
      else           pA += p;

      const sum = h+a;
      if(sum > 0) ou["0.5"].over += p; else ou["0.5"].under += p;
      if(sum > 1) ou["1.5"].over += p; else ou["1.5"].under += p;
      if(sum > 2) ou["2.5"].over += p; else ou["2.5"].under += p;
      if(sum > 3) ou["3.5"].over += p; else ou["3.5"].under += p;
    }
  }

  if(total>0){
    pH/=total; pD/=total; pA/=total;
    Object.values(ou).forEach(x=>{
      x.over/=total; x.under/=total;
    });
  }

  return {pH,pD,pA,ou};
};


// -------------------------------------------------------------
// CHAOS MODEL — menambah/kurang intensitas
// -------------------------------------------------------------
V20.chaosModel = function(lambda, ctx){
  lambda = lambda || {};
  ctx    = ctx || {};

  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);
  const chaos = ctx.chaos || 5;

  const chaosF = (chaos - 5)/5;
  const factor = 1 + V20.clamp(chaosF*0.24, -0.22, 0.32);

  return {
    lamH: V20.clamp(lamH*factor, 0.20, 6.00),
    lamA: V20.clamp(lamA*factor, 0.20, 6.00)
  };
};


// -------------------------------------------------------------
// MONTE CARLO — Multi-Reality Divine Engine
// -------------------------------------------------------------
V20.monteCarlo = function(lambda, ctx, simCount, scoreCap, home, away, tact){
  lambda = lambda || {};
  ctx    = ctx || {};
  home   = home || {stability:5, momentum:5};
  away   = away || {stability:5, momentum:5};
  tact   = tact || {
    home:{pressIntensity:5, flex:0.5},
    away:{pressIntensity:5, flex:0.5}
  };

  // Dapatkan Hyper Lambda
  const HL = V20.hyperLambda(lambda, ctx, home, away, tact);
  const lamH_base = HL.lamH;
  const lamA_base = HL.lamA;
  const totalLam = lamH_base + lamA_base || 0.0001;

  const pat = HL.pattern;

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;
  const imp   = ctx.importance || 5;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  const impF   = (imp   - 5)/5;

  // Default simulasi
  const baseSim = simCount ? V20.num(simCount, 50000) : 50000;

  // Pola → adjust sim weight
  let patternScale =
      1.00
    + pat.swing   * 0.30
    + pat.chaotic * 0.35
    - pat.stalled * 0.25;

  const globalAdj =
      chaosF*0.35 +
      tempoF*0.25 +
      impF  *0.15;

  let simScaled = baseSim * (1 + globalAdj*0.7) * patternScale;
  simScaled = V20.clamp(simScaled, 30000, 250000);
  simCount  = Math.round(simScaled);

  // Score Cap
  const autoCap = totalLam > 3.4 ? 6 : 5;
  scoreCap = V20.clamp(scoreCap || autoCap, 3, 8);

  // Phase
  const phases = [
    {name:"early", w:0.25},
    {name:"mid",   w:0.50},
    {name:"late",  w:0.25}
  ];
  let acc=0;
  phases.forEach(p=>{ acc+=p.w; p.cum=acc; });

  function pickPhase(){
    const r = Math.random();
    for(let p of phases){
      if(r <= p.cum) return p;
    }
    return phases[2];
  }

  // Reality A / B / C
  const realityWeights = {
    A: 0.40 + pat.control*0.20,
    B: 0.30 + pat.chaotic*0.30,
    C: 0.30 + pat.swing*0.30
  };
  let wSum = realityWeights.A + realityWeights.B + realityWeights.C;
  realityWeights.A/=wSum;
  realityWeights.B/=wSum;
  realityWeights.C/=wSum;

  function pickReality(){
    const r = Math.random();
    if(r <= realityWeights.A) return "A";
    if(r <= realityWeights.A + realityWeights.B) return "B";
    return "C";
  }

  function realityParams(type){
    let fH=1, fA=1, spread=0.6;
    if(type==="A"){
      fH=1.00; fA=1.00; spread=0.45;
    } else if(type==="B"){
      fH=1.00 + Math.max(0,chaosF)*0.20;
      fA=1.00 + Math.max(0,chaosF)*0.20;
      spread = 0.6 + Math.max(0,chaosF)*0.6;
    } else {
      const swingBoost   = pat.swing*0.10;
      const chaoticBoost = pat.chaotic*0.12;
      fH = 1.00 + swingBoost + chaoticBoost;
      fA = 1.00 + swingBoost + chaoticBoost;
      spread = 0.6 + (pat.chaotic+pat.swing)*0.6;
    }
    return {fH,fA,spread};
  }

  // Scenario
  const ratioH = lamH_base / totalLam;
  const scenarios = [
    {name:"base",      w:0.30, fH:1.00, fA:1.00},
    {name:"control",   w:0.08 + 0.25*pat.control, fH:0.97, fA:0.97},
    {name:"swing",     w:0.08 + 0.25*pat.swing,   fH:1.07, fA:1.07},
    {name:"stalled",   w:0.06 + 0.22*pat.stalled, fH:0.78, fA:0.78},
    {name:"chaotic",   w:0.06 + 0.22*pat.chaotic, fH:1.18, fA:1.18},
    {name:"homeFront", w:0.06 + 0.10*ratioH,      fH:1.08, fA:0.97},
    {name:"awayFront", w:0.06 + 0.10*(1-ratioH),  fH:0.97, fA:1.08},
    {name:"wideOpen",  w:0.04 + 0.12*Math.max(0,tempoF)*Math.max(0,chaosF), 
                       fH:1.22, fA:1.22}
  ];

  // Penalti
  scenarios.forEach(s=>{
    if(s.name==="wideOpen") s.w*=0.90;
    if(s.name==="chaotic")  s.w*=0.93;
    if(s.name==="stalled")  s.w*=0.95;
  });

  // Normalize scenario
  let scSum = 0;
  scenarios.forEach(s=>scSum+=s.w);
  scenarios.forEach(s=>s.p = s.w/scSum);

  // Cumulative
  let cum = 0;
  scenarios.forEach(s=>{ cum+=s.p; s.cum=cum; });

  function pickScenario(){
    const r = Math.random();
    for(let s of scenarios){
      if(r <= s.cum) return s;
    }
    return scenarios[scenarios.length-1];
  }

  function sampleHybrid(lambdaBase, spreadBase){
    lambdaBase = Math.max(lambdaBase, 0.00001);
    const r = Math.random();
    if(r < 0.55){
      return V20.samplePoisson(lambdaBase);
    } else if(r < 0.85){
      const factor = Math.exp((Math.random()-0.5)*spreadBase);
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.2);
      return V20.samplePoisson(lamVar);
    } else {
      const factor = Math.exp((Math.random()-0.5)*(spreadBase+0.4));
      const lamVar = V20.clamp(lambdaBase*factor, 0.05, 6.8);
      return V20.samplePoisson(lamVar);
    }
  }

  let homeWins=0, draws=0, awayWins=0;
  let total=0, goalsTotal=0;

  const matrix=[];
  for(let h=0;h<=scoreCap;h++){
    matrix[h]=[];
    for(let a=0;a<=scoreCap;a++){
      matrix[h][a]=0;
    }
  }

  const scenarioCount = {};
  scenarios.forEach(s=>scenarioCount[s.name]=0);

  // MAIN LOOP
  for(let i=0;i<simCount;i++){
    const phase   = pickPhase();
    const sc      = pickScenario();
    const reality = pickReality();

    scenarioCount[sc.name]++;

    const rp = realityParams(reality);

    const lamH_sim = lamH_base * sc.fH * rp.fH;
    const lamA_sim = lamA_base * sc.fA * rp.fA;

    const h = sampleHybrid(lamH_sim, rp.spread);
    const a = sampleHybrid(lamA_sim, rp.spread);

    total++;
    goalsTotal += (h+a);

    if(h>a) homeWins++;
    else if(h===a) draws++;
    else awayWins++;

    if(h<=scoreCap && a<=scoreCap){
      matrix[h][a]++;
    }
  }

  return{
    simCount,
    pH: homeWins/total,
    pD: draws/total,
    pA: awayWins/total,
    avgGoals: goalsTotal/total,
    matrix,
    scoreCap,
    god:{
      hyperLambda:{lamH:lamH_base, lamA:lamA_base},
      pattern: pat
    },
    scenarioStats:{
      scenarios,
      count:scenarioCount
    }  
  };
};


// =============================================================
// PART 3 SELESAI
// Selanjutnya PART 4:
// • Risk Model
// • Fragility
// • Meta Consistency
// • Flow Model
// • Singularity Zero Layer
// =============================================================
  </script>
  <script>
// =============================================================
// PART 4 — RISK, FRAGILITY, META, FLOW & SINGULARITY ZERO LAYER
// =============================================================


// -------------------------------------------------------------
// RISK MODEL — seberapa tinggi ketidakpastian pertandingan
// -------------------------------------------------------------
V20.computeRisk = function(ctx, tact){
  ctx  = ctx  || {};
  tact = tact || {home:{flex:0.5}, away:{flex:0.5}};

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const flexH = tact.home.flex || 0.5;
  const flexA = tact.away.flex || 0.5;
  const flexAvg = (flexH + flexA)/2;

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;

  let risk = 0.42
           + chaosF*0.33
           + tempoF*0.18
           + flexAvg*0.20;

  return V20.clamp(risk, 0, 1);
};


// -------------------------------------------------------------
// FRAGILITY MODEL — seberapa mudah hasil berubah arah
// -------------------------------------------------------------
V20.computeFragility = function(ctx, home, away){
  ctx  = ctx  || {};
  home = home || {stability:5};
  away = away || {stability:5};

  const chaos = ctx.chaos || 5;
  const stH   = home.stability || 5;
  const stA   = away.stability || 5;

  const stabAvg = (stH + stA)/2;
  const chaosF  = (chaos - 5)/5;
  const stabF   = (stabAvg - 5)/5;

  let frag = 0.40
            + chaosF*0.30
            - stabF*0.25;

  return V20.clamp(frag, 0, 1);
};


// -------------------------------------------------------------
// SDI — Score Direction Index (arah tren skor)
// -------------------------------------------------------------
V20.computeSDI = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.01);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.01);

  const gap = lamH - lamA;
  return V20.clamp(gap/2.5, -1, 1);
};


// -------------------------------------------------------------
// META CONSISTENCY — konsistensi antar-lapisan model
// -------------------------------------------------------------
V20.computeMeta = function(det, chaosM, sdi){
  if(!det || !chaosM) return 0.5;

  const detGap   = det.pH - det.pA;
  const chaosGap = chaosM.pH - chaosM.pA;

  let meta = 1 - (Math.abs(detGap - chaosGap)*0.45
                + Math.abs(sdi)*0.20);

  return V20.clamp(meta, 0, 1);
};


// -------------------------------------------------------------
// FLOW MODEL — momentum + pressing + pattern
// -------------------------------------------------------------
V20.computeFlow = function(ctx, home, away, tact, pat){
  ctx  = ctx  || {};
  home = home || {momentum:5};
  away = away || {momentum:5};
  tact = tact || {
    home:{pressIntensity:5},
    away:{pressIntensity:5}
  };
  pat  = pat  || {swing:0.25, chaotic:0.25};

  const chaos = ctx.chaos || 5;
  const tempo = ctx.tempo || 5;

  const momH = home.momentum || 5;
  const momA = away.momentum || 5;
  const mg = momH - momA;

  const pressH = tact.home.pressIntensity || 5;
  const pressA = tact.away.pressIntensity || 5;
  const pg = pressH - pressA;

  let flow = mg*0.10 + pg*0.08;

  // pattern influence
  flow += (pat.swing*0.10 + pat.chaotic*0.06) * (mg/7);

  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  flow += chaosF*0.05 + tempoF*0.03;

  return V20.clamp(flow, -1, 1);
};


// -------------------------------------------------------------
// MOMENTUM SWING — perubahan tren (swing positif/negatif)
// -------------------------------------------------------------
V20.computeMomentumSwing = function(home, away){
  home = home || {momentum:5};
  away = away || {momentum:5};

  const mH = home.momentum || 5;
  const mA = away.momentum || 5;

  const base = (mH - mA)/10;
  return V20.clamp(base*1.1, -1, 1);
};


// -------------------------------------------------------------
// PRIME SINGULARITY ZERO — koreksi final probabilitas
// -------------------------------------------------------------
V20.singularityZero = function(raw, risk, frag, meta, flow, swing){
  raw = raw || {};
  let pH = raw.pH || 0.33;
  let pD = raw.pD || 0.33;
  let pA = raw.pA || 0.33;

  const riskF = risk;
  const fragF = frag;
  const metaF = meta;

  const lowMeta  = 1 - metaF;
  const highRisk = riskF;
  const highFrag = fragF;

  // Kompresi probabilitas ketika ketidakpastian tinggi
  const compress = 0.50
                 + lowMeta*0.35
                 + highRisk*0.30
                 + highFrag*0.30;

  const comp = V20.clamp(compress, 0, 0.99);

  let center = (pH + pA)/2;
  pH = center + (pH-center)*(1-comp);
  pA = center + (pA-center)*(1-comp);

  // Flow & Swing Adjustment
  pH *= (1 + flow*0.14 + swing*0.10);
  pA *= (1 - flow*0.14 - swing*0.10);

  // Draw adjustment
  const floor = 0.06;
  const addD  = Math.abs(pH - pA)*0.22;
  pD += addD;

  pH = Math.max(pH - pD*0.10, floor);
  pA = Math.max(pA - pD*0.10, floor);
  pD = Math.max(pD, floor);

  // Normalize 1
  let s = pH + pD + pA;
  pH/=s; pD/=s; pA/=s;

  // Final directional influence
  if(flow > 0 && swing > 0){
    pH *= (1 + 0.07*flow + 0.05*swing);
    pA *= (1 - 0.07*flow - 0.05*swing);
  }
  else if(flow < 0 && swing < 0){
    pA *= (1 + 0.07*(-flow) + 0.05*(-swing));
    pH *= (1 - 0.07*(-flow) - 0.05*(-swing));
  }

  // Normalize 2
  let s2 = pH + pD + pA;
  pH/=s2; pD/=s2; pA/=s2;

  return {pH,pD,pA};
};


// -------------------------------------------------------------
// OUTPUT FUSION
// -------------------------------------------------------------
V20.fuseOutputs = function(det, chaosM, mc, zero){
  return {
    raw:{
      deterministic: det,
      chaos: chaosM,
      mc: mc
    },
    final:{
      pH: zero.pH,
      pD: zero.pD,
      pA: zero.pA
    }
  };
};


// =============================================================
// PART 4 SELESAI
/ taee jikaPART 5 = FINAL ENGINE RUNNER + AUTO-CALC + AUTO-TCI + OUTPUT
// =============================================================
  </script>
  <script>
// =============================================================
// PART 5 — AUTO-CALC + AUTO-FILL TCI + ENGINE RUNNER + OUTPUT
// =============================================================

// -------------------------------------------------------------
// AUTO-CALC INPUT WAJIB (ADVANCED MODE)
// -------------------------------------------------------------
V20.autoCalcRequired = function(){
  const outEl = document.getElementById('output');

  // baca advanced stats
  const xgH   = V20.num(document.getElementById('adv_xg_home').value, NaN);
  const xgA   = V20.num(document.getElementById('adv_xg_away').value, NaN);
  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);

  const fHw = V20.num(document.getElementById('adv_form_home_w').value, 0);
  const fHd = V20.num(document.getElementById('adv_form_home_d').value, 0);
  const fHl = V20.num(document.getElementById('adv_form_home_l').value, 0);

  const fAw = V20.num(document.getElementById('adv_form_away_w').value, 0);
  const fAd = V20.num(document.getElementById('adv_form_away_d').value, 0);
  const fAl = V20.num(document.getElementById('adv_form_away_l').value, 0);

  const ppdaH = V20.num(document.getElementById('adv_ppda_home').value, NaN);
  const ppdaA = V20.num(document.getElementById('adv_ppda_away').value, NaN);

  const errH  = V20.num(document.getElementById('adv_err_home').value, 0);
  const errA  = V20.num(document.getElementById('adv_err_away').value, 0);

  const formH = V20.num(document.getElementById('adv_formasi_home').value, 1);
  const formA = V20.num(document.getElementById('adv_formasi_away').value, 1);

  // ---- 1) λH & λA dari xG + xGA ----
  let lamH = 1.20;
  let lamA = 1.00;

  if (isFinite(xgH) && isFinite(xgaA)){
    lamH = 0.60 * xgH + 0.40 * xgaA;
  }
  if (isFinite(xgA) && isFinite(xgaH)){
    lamA = 0.60 * xgA + 0.40 * xgaH;
  }

  lamH = V20.clamp(lamH, 0.20, 4.50);
  lamA = V20.clamp(lamA, 0.20, 4.50);

  document.getElementById('lamH').value = lamH.toFixed(2);
  document.getElementById('lamA').value = lamA.toFixed(2);

  // ---- 2) Momentum (1–10) dari W/D/L ----
  function calcMomentum(W,D,L){
    const total = W+D+L;
    if (total <= 0) return 5;
    const rawScore = (3*W + 1*D - 2*L) / (3*5);  // kira-kira -? .. +1
    const norm = V20.clamp(0.5 + rawScore, 0, 1);
    return V20.clamp(1 + 9*norm, 1, 10);
  }

  const momH = calcMomentum(fHw,fHd,fHl);
  const momA = calcMomentum(fAw,fAd,fAl);

  document.getElementById('home_mom').value = momH.toFixed(1);
  document.getElementById('away_mom').value = momA.toFixed(1);

  // ---- 3) Stability (1–10) dari xGA + error ----
  function calcStability(xga, err){
    if (!isFinite(xga)) xga = 1.2;
    const base = 8.0 - (xga-1.0)*2.5 - err*1.2;
    return V20.clamp(base, 1, 10);
  }

  const stH = calcStability(xgaH, errH);
  const stA = calcStability(xgaA, errA);

  document.getElementById('home_st').value = stH.toFixed(1);
  document.getElementById('away_st').value = stA.toFixed(1);

  // ---- 4) Press Intensity (1–10) dari PPDA ----
  function calcPress(ppda){
    if (!isFinite(ppda)) return 5;
    // PPDA 4 → press ~9–10, PPDA 20 → press ~1–2
    const press = 11 - (ppda-4)*0.6;
    return V20.clamp(press, 1, 10);
  }

  const pressH = calcPress(ppdaH);
  const pressA = calcPress(ppdaA);

  document.getElementById('home_press').value = pressH.toFixed(1);
  document.getElementById('away_press').value = pressA.toFixed(1);

  // ---- 5) Flex (0–1) dari jumlah formasi aktif ----
  function calcFlex(formCount){
    if (formCount <= 1) return 0.20;
    if (formCount >= 3) return 0.80;
    return 0.50; // 2 formasi aktif
  }

  const flexH = calcFlex(formH);
  const flexA = calcFlex(formA);

  document.getElementById('home_flex').value = flexH.toFixed(2);
  document.getElementById('away_flex').value = flexA.toFixed(2);

  // Log singkat ke output
  if (outEl){
    let log = "";
    log += "[AUTO-CALC INPUT WAJIB — ADVANCED MODE]\n";
    log += `λH : ${lamH.toFixed(3)} | λA : ${lamA.toFixed(3)}\n`;
    log += `Momentum H/A : ${momH.toFixed(1)} / ${momA.toFixed(1)}\n`;
    log += `Stability H/A: ${stH.toFixed(1)} / ${stA.toFixed(1)}\n`;
    log += `Press H/A    : ${pressH.toFixed(1)} / ${pressA.toFixed(1)}\n`;
    log += `Flex H/A     : ${flexH.toFixed(2)} / ${flexA.toFixed(2)}\n\n`;
    outEl.value = log + (outEl.value || "");
  }

  alert("Auto-calc selesai. Input utama sudah terisi.");
};
// -------------------------------------------------------------
// AUTO-ESTIMATE PPDA dari gaya pressing + xGA + error
// -------------------------------------------------------------
V20.autoEstimatePPDA = function(){
  const outEl = document.getElementById('output');

  const styleH = (document.getElementById('press_style_home') || {}).value || "";
  const styleA = (document.getElementById('press_style_away') || {}).value || "";

  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);
  const errH  = V20.num(document.getElementById('adv_err_home').value, NaN);
  const errA  = V20.num(document.getElementById('adv_err_away').value, NaN);

  function basePPDA(style){
    switch(style){
      case "high":     return 6.5;   // high press
      case "mid_high": return 9.0;   // mid–high
      case "mid":      return 12.0;  // mid block
      case "mid_low":  return 15.0;  // mid–low
      case "low":      return 18.0;  // low block
      // Tambahan gaya pressing lengkap
case "extreme_high": return 5.0;
case "gegenpress": return 7.0;
case "hybrid_press": return 10.0;
case "deep_low": return 20.0;

case "man_marking_high": return 5.5;
case "positional_high": return 7.5;
case "semi_gegenpress": return 8.2;
case "reactive_press": return 13.5;
case "wing_press": return 14.5;
case "inverted_press": return 10.0;
case "zonal_midlow": return 17.5;
case "ultra_compact": return 19.5;
      default:         return 12.0;  // netral
    }
  }

  function refine(ppda, xga, err){
    let v = ppda;

    // xGA kecil → tim sulit ditembus → press cenderung lebih agresif / rapi
    if (isFinite(xga)){
      if (xga < 1.0)      v -= 0.8;
      else if (xga > 1.6) v += 0.8;
    }

    // error tinggi → press sering telat / salah → PPDA cenderung naik
    if (isFinite(err)){
      if (err > 1.0) v += 0.8;
      else if (err < 0.5) v -= 0.4;
    }

    return V20.clamp(v, 4.0, 22.0);
  }

  let ppdaH = basePPDA(styleH || "mid");
  let ppdaA = basePPDA(styleA || "mid");

  ppdaH = refine(ppdaH, xgaH, errH);
  ppdaA = refine(ppdaA, xgaA, errA);

  const elH = document.getElementById('adv_ppda_home');
  const elA = document.getElementById('adv_ppda_away');

  if (elH) elH.value = ppdaH.toFixed(2);
  if (elA) elA.value = ppdaA.toFixed(2);

  if (outEl){
    let log = "[AUTO-ESTIMATE PPDA]\n";
    log += `PPDA Home (est) : ${ppdaH.toFixed(2)}\n`;
    log += `PPDA Away (est) : ${ppdaA.toFixed(2)}\n`;
    log += `(Berdasarkan gaya pressing + xGA + error)\n\n`;
    outEl.value = log + (outEl.value || "");
  }

  alert("Estimasi PPDA selesai. PPDA Home/Away sudah terisi.");
};
    

// -------------------------------------------------------------
// AUTO-FILL TEMPO / CHAOS / IMPORTANCE
// -------------------------------------------------------------
V20.autoFillTCI = function(){
  const outEl = document.getElementById('output');

  const xgH   = V20.num(document.getElementById('adv_xg_home').value, NaN);
  const xgA   = V20.num(document.getElementById('adv_xg_away').value, NaN);
  const xgaH  = V20.num(document.getElementById('adv_xga_home').value, NaN);
  const xgaA  = V20.num(document.getElementById('adv_xga_away').value, NaN);

  const ppdaH = V20.num(document.getElementById('adv_ppda_home').value, NaN);
  const ppdaA = V20.num(document.getElementById('adv_ppda_away').value, NaN);

  const errH  = V20.num(document.getElementById('adv_err_home').value, NaN);
  const errA  = V20.num(document.getElementById('adv_err_away').value, NaN);

  const matchType  = (document.getElementById('auto_match_type')  || {}).value || "";
  const matchStyle = (document.getElementById('auto_match_style') || {}).value || "";

  // nilai awal netral
  let tempo = 5;
  let chaos = 5;
  let importance = 5;

  // 1) jenis laga
  switch (matchType){
    case "friendly":
      importance = 2.5;
      tempo     -= 0.5;
      chaos     -= 0.5;
      break;
    case "league_normal":
      importance = 4.5;
      break;
    case "big_match":
      importance = 6.5;
      tempo     += 0.5;
      break;
    case "derby":
      importance = 8.0;
      tempo     += 0.8;
      chaos     += 1.0;
      break;
    case "final":
      importance = 9.5;
      tempo     += 0.5;
      chaos     += 0.8;
      break;
    default:
      importance = 5.0;
  }

  // 2) gaya pertandingan
  switch (matchStyle){
    case "slow_structured":
      tempo -= 1.5;
      chaos -= 1.5;
      break;
    case "balanced":
      break;
    case "fast_open":
      tempo += 1.5;
      chaos += 1.0;
      break;
    case "wild":
      tempo += 2.0;
      chaos += 2.2;
      break;
  }

  // 3) xG/xGA → intensitas serangan
  let avgXg = NaN;
  if (isFinite(xgH) && isFinite(xgA)){
    avgXg = (xgH + xgA)/2;
    tempo += (avgXg - 1.5) * 1.5;
    chaos += (avgXg - 1.5) * 1.0;
  }

  // 4) PPDA → pressing & chaos
  let avgPPDA = NaN;
  if (isFinite(ppdaH) && isFinite(ppdaA)){
    avgPPDA = (ppdaH + ppdaA)/2;
    if (avgPPDA <= 8){
      tempo += 1.0;
      chaos += 1.4;
    } else if (avgPPDA <= 11){
      tempo += 0.3;
      chaos += 0.6;
    } else if (avgPPDA >= 16){
      tempo -= 0.7;
      chaos -= 0.7;
    }
  }

  // 5) error → chaos
  let avgErr = NaN;
  if (isFinite(errH) && isFinite(errA)){
    avgErr = (errH + errA)/2;
    chaos += avgErr * 0.5;
  }

  tempo      = V20.clamp(tempo, 1, 10);
  chaos      = V20.clamp(chaos, 1, 10);
  importance = V20.clamp(importance, 1, 10);

  const tempoEl = document.getElementById('tempo');
  const chaosEl = document.getElementById('chaos');
  const impEl   = document.getElementById('importance');

  if (tempoEl) tempoEl.value = tempo.toFixed(1);
  if (chaosEl) chaosEl.value = chaos.toFixed(1);
  if (impEl)   impEl.value   = importance.toFixed(1);

  if (outEl){
    let log = "[AUTO-FILL TEMPO / CHAOS / IMPORTANCE]\n";
    log += `Tempo       : ${tempo.toFixed(1)}\n`;
    log += `Chaos       : ${chaos.toFixed(1)}\n`;
    log += `Importance  : ${importance.toFixed(1)}\n`;
    if (isFinite(avgXg))   log += `avg xG      : ${avgXg.toFixed(2)}\n`;
    if (isFinite(avgPPDA)) log += `avg PPDA    : ${avgPPDA.toFixed(2)}\n`;
    if (isFinite(avgErr))  log += `avg Error   : ${avgErr.toFixed(2)}\n`;
    log += "\n";
    outEl.value = log + (outEl.value || "");
  }

  alert("Auto-fill Tempo / Chaos / Importance selesai.");
};


// -------------------------------------------------------------
// UNCERTAINTY (ENTROPI 1X2)
// -------------------------------------------------------------
V20.computeUncertainty = function(pH,pD,pA){
  const probs = [pH,pD,pA];
  let entropy = 0;
  probs.forEach(p=>{
    if (p>0) entropy -= p*Math.log2(p);
  });
  const maxE = Math.log2(3);
  const norm = maxE>0 ? entropy/maxE : 0;
  return {
    entropy,
    norm,
    score: norm*100
  };
};


// -------------------------------------------------------------
// BTTS (Both Teams To Score) dari λ
// -------------------------------------------------------------
V20.computeBTTS = function(lambda){
  lambda = lambda || {};
  const lamH = Math.max(V20.num(lambda.lamH,1.0), 0.0001);
  const lamA = Math.max(V20.num(lambda.lamA,1.0), 0.0001);

  const pH0 = Math.exp(-lamH);
  const pA0 = Math.exp(-lamA);
  const p00 = Math.exp(-(lamH+lamA));

  const pBTTS = 1 - (pH0 + pA0 - p00);
  return V20.clamp(pBTTS, 0, 1);
};


// -------------------------------------------------------------
// ENGINE RUNNER — PRIME SINGULARITY ZERO ∑.REBUILD
// -------------------------------------------------------------
V20.runPrimeZero = function(){
  const outEl = document.getElementById('output');
  if (!outEl) return;

  // --- BACA INPUT ---
  const lamH  = V20.num(document.getElementById('lamH').value, 1.20);
  const lamA  = V20.num(document.getElementById('lamA').value, 1.00);

  const tempo = V20.num(document.getElementById('tempo').value, 5);
  const chaos = V20.num(document.getElementById('chaos').value, 5);
  const importance = V20.num(document.getElementById('importance').value, 5);

  const home_st  = V20.num(document.getElementById('home_st').value, 5);
  const away_st  = V20.num(document.getElementById('away_st').value, 5);
  const home_mom = V20.num(document.getElementById('home_mom').value, 5);
  const away_mom = V20.num(document.getElementById('away_mom').value, 5);

  const home_press = V20.num(document.getElementById('home_press').value, 5);
  const away_press = V20.num(document.getElementById('away_press').value, 5);
  const home_flex  = V20.num(document.getElementById('home_flex').value, 0.5);
  const away_flex  = V20.num(document.getElementById('away_flex').value, 0.5);

  let simCount  = V20.num(document.getElementById('simCount').value, NaN);
  let scoreCap  = V20.num(document.getElementById('scoreCap').value, NaN);
  if (!isFinite(simCount)) simCount = undefined;
  if (!isFinite(scoreCap)) scoreCap = undefined;

  const lambda = { lamH, lamA };
  const ctx = { tempo, chaos, importance };
  const home = { stability: home_st, momentum: home_mom };
  const away = { stability: away_st, momentum: away_mom };
  const tact = {
    home: { pressIntensity: home_press, flex: home_flex },
    away: { pressIntensity: away_press, flex: away_flex }
  };

  // --- MODEL INTI ---
  const det       = V20.detSim(lambda);
  const chaosL    = V20.chaosModel(lambda, ctx);
  const detChaos  = V20.detSim(chaosL);
  const mc        = V20.monteCarlo(lambda, ctx, simCount, scoreCap, home, away, tact);

  const godHL  = mc.god && mc.god.hyperLambda ? mc.god.hyperLambda : {lamH, lamA};
  const godPat = mc.god && mc.god.pattern ? mc.god.pattern : {control:0.25,swing:0.25,stalled:0.25,chaotic:0.25};

  // baseline 1X2 (gabungan 3 model)
  const base = {
    pH: (det.pH + detChaos.pH + mc.pH)/3,
    pD: (det.pD + detChaos.pD + mc.pD)/3,
    pA: (det.pA + detChaos.pA + mc.pA)/3
  };

  // --- METRIK LANJUTAN ---
  const risk01   = V20.computeRisk(ctx, tact);
  const frag01   = V20.computeFragility(ctx, home, away);
  const sdi      = V20.computeSDI(godHL);
  const meta01   = V20.computeMeta(det, detChaos, sdi);
  const flowVal  = V20.computeFlow(ctx, home, away, tact, godPat);
  const swingVal = V20.computeMomentumSwing(home, away);

  const zeroProb = V20.singularityZero(base, risk01, frag01, meta01, flowVal, swingVal);
  const fused    = V20.fuseOutputs(det, detChaos, mc, zeroProb);

  const unc   = V20.computeUncertainty(fused.final.pH, fused.final.pD, fused.final.pA);
  const btts  = V20.computeBTTS(godHL);

  const riskScore = risk01*100;
  const fragScore = frag01*100;
  const metaScore = meta01*100;

  let engineStatus = "PRIME STABLE";
  if (metaScore < 40 || riskScore > 70 || fragScore > 70){
    engineStatus = "PRIME CAUTION";
  } else if (metaScore < 60){
    engineStatus = "PRIME NEUTRAL";
  }

  // --- O/U dari MC + Analytic blend ---
  const totalLamBase = godHL.lamH + godHL.lamA;
  let lamEff = totalLamBase;
  const chaosF = (chaos - 5)/5;
  const tempoF = (tempo - 5)/5;
  lamEff *= (1 + chaosF*0.10 + tempoF*0.05);
  lamEff = V20.clamp(lamEff, 0.5, 5.8);

  const lines = [0.5,1.5,2.5,3.5];
  const ouAn = {};
  const ouMC = {};
  const ou   = {};

  // analytic Poisson OU (total goals)
  lines.forEach(line=>{
    const cut = Math.floor(line);
    let under=0;
    for(let k=0;k<=cut;k++){
      under += V20.poissonPMF(lamEff,k);
    }
    ouAn[line] = {under, over:1-under};
  });

  // MC OU
  const mat = mc.matrix;
  const cap = mc.scoreCap;
  lines.forEach(line=>{
    const cut = Math.floor(line);
    let under=0, over=0;
    for(let h=0;h<=cap;h++){
      for(let a=0;a<=cap;a++){
        const sum = h+a;
        const freq = (mat[h] && mat[h][a]) ? mat[h][a] : 0;
        if(sum<=cut) under += freq;
        else over += freq;
      }
    }
    ouMC[line] = {
      under: under/mc.simCount,
      over:  over/mc.simCount
    };
  });

  // blend OU
  const patternChaos = godPat.chaotic + godPat.swing*0.6;
  const wMC = 0.40 + 0.40*Math.max(0,patternChaos);
  const wAN = 1 - wMC;

  lines.forEach(line=>{
    ou[line] = {
      over: ouAn[line].over*wAN + ouMC[line].over*wMC,
      under:ouAn[line].under*wAN + ouMC[line].under*wMC
    };
  });

  // --- SUSUN OUTPUT TEKS ---
  let text = "";
  text += "=== MATCH SIMULATION REPORT — PRIME SINGULARITY ZERO ∑.REBUILD ===\n\n";

  text += "[ENGINE STATUS]\n";
  text += "Core    : Pattern Oracle + Hyper Lambda + Multi-Reality MC + Singularity Zero\n";
  text += `Status  : ${engineStatus}\n\n`;

  text += "[INPUT]\n";
  text += `λH (input) : ${lamH.toFixed(3)}\n`;
  text += `λA (input) : ${lamA.toFixed(3)}\n`;
  text += `Tempo       : ${tempo.toFixed(1)}\n`;
  text += `Chaos       : ${chaos.toFixed(1)}\n`;
  text += `Importance  : ${importance.toFixed(1)}\n`;
  text += `Home Stab   : ${home_st.toFixed(1)} | Mom: ${home_mom.toFixed(1)}\n`;
  text += `Away Stab   : ${away_st.toFixed(1)} | Mom: ${away_mom.toFixed(1)}\n`;
  text += `Press H/A   : ${home_press.toFixed(1)} / ${away_press.toFixed(1)}\n`;
  text += `Flex  H/A   : ${home_flex.toFixed(2)} / ${away_flex.toFixed(2)}\n`;
  text += `SimCount    : ${mc.simCount}\n`;
  text += `Score Cap   : ${mc.scoreCap}\n\n`;

  text += "[GOD HYPER LAMBDA]\n";
  text += `λH (Hyper) : ${godHL.lamH.toFixed(3)}\n`;
  text += `λA (Hyper) : ${godHL.lamA.toFixed(3)}\n\n`;

  text += "[PATTERN ORACLE]\n";
  text += `Control : ${(godPat.control*100).toFixed(1)}%\n`;
  text += `Swing   : ${(godPat.swing*100).toFixed(1)}%\n`;
  text += `Stalled : ${(godPat.stalled*100).toFixed(1)}%\n`;
  text += `Chaotic : ${(godPat.chaotic*100).toFixed(1)}%\n`;

  let domPattern = "control";
  let best = godPat.control;
  if (godPat.swing   > best){ domPattern = "swing";   best = godPat.swing; }
  if (godPat.stalled > best){ domPattern = "stalled"; best = godPat.stalled; }
  if (godPat.chaotic > best){ domPattern = "chaotic"; best = godPat.chaotic; }

  text += `Dominant Pattern : ${domPattern.toUpperCase()}\n\n`;

  text += "[1X2 PROBABILITIES — PRIME SINGULARITY ZERO]\n";
  text += `Home Win : ${(fused.final.pH*100).toFixed(1)}%\n`;
  text += `Draw     : ${(fused.final.pD*100).toFixed(1)}%\n`;
  text += `Away Win : ${(fused.final.pA*100).toFixed(1)}%\n\n`;

  text += "[RISK / FRAGILITY / META / UNCERTAINTY]\n";
  text += `Risk Index        : ${riskScore.toFixed(1)} / 100\n`;
  text += `Fragility Index   : ${fragScore.toFixed(1)} / 100\n`;
  text += `Meta-Consistency  : ${metaScore.toFixed(1)} / 100\n`;
  text += `Uncertainty (1X2) : ${unc.score.toFixed(1)} / 100\n`;
  text += `Flow Value        : ${flowVal.toFixed(3)} (H+ vs A-)\n`;
  text += `Momentum Swing    : ${swingVal.toFixed(3)}\n\n`;

  text += "[GOAL MODEL]\n";
  text += `Avg Goals (MC)       : ${mc.avgGoals.toFixed(3)}\n`;
  text += `BTTS (kedua tim gol) : ${(btts*100).toFixed(1)}%\n\n`;

  text += "[OVER/UNDER (Blend MC + Analytic)]\n";
  ["0.5","1.5","2.5","3.5"].forEach(k=>{
    const o = ou[k] || {over:0,under:0};
    text += `O/U ${k}  -> Over: ${(o.over*100).toFixed(1)}% | Under: ${(o.under*100).toFixed(1)}%\n`;
  });
  text += "\n";

  text += "[SCENARIO DISTRIBUTION]\n";
  if (mc.scenarioStats && mc.scenarioStats.scenarios){
    mc.scenarioStats.scenarios.forEach(s=>{
      const p = s.p || 0;
      text += `${(s.name || "").padEnd(10," ")} : ${(p*100).toFixed(1)}%\n`;
    });
  }
  text += "\n";

  text += "[SCORE MATRIX] (frekuensi relatif simulasi)\n";
  text += "     ";
  for(let a=0;a<=mc.scoreCap;a++){
    text += `A${a}    `;
  }
  text += "\n";

  for(let h=0;h<=mc.scoreCap;h++){
    text += `H${h}  `;
    for(let a=0;a<=mc.scoreCap;a++){
      const v = (mc.matrix[h] && mc.matrix[h][a]) ? mc.matrix[h][a]/mc.simCount : 0;
      text += v.toFixed(3).padEnd(7," ");
    }
    text += "\n";
  }

  outEl.value = text;
};


// -------------------------------------------------------------
// EVENT LISTENER TOMBOL
// -------------------------------------------------------------
window.addEventListener('DOMContentLoaded', function(){
  const btnAnalyze = document.getElementById('btn_analyze');
  if (btnAnalyze){
    btnAnalyze.addEventListener('click', function(){
      try {
        V20.runPrimeZero();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat menjalankan PRIME SINGULARITY ZERO. Cek console.");
      }
    });
  }

  const btnAuto = document.getElementById('btn_auto_calc');
  if (btnAuto){
    btnAuto.addEventListener('click', function(){
      try {
        V20.autoCalcRequired();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat AUTO-CALC. Cek console & input advanced.");
      }
    });
  }

  const btnAutoTCI = document.getElementById('btn_auto_tci');
  if (btnAutoTCI){
    btnAutoTCI.addEventListener('click', function(){
      try {
        V20.autoFillTCI();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat AUTO-FILL Tempo/Chaos/Importance. Cek input & console.");
      }
    });
  }

  const btnAutoPPDA = document.getElementById('btn_auto_ppda');
  if (btnAutoPPDA){
    btnAutoPPDA.addEventListener('click', function(){
      try {
        V20.autoEstimatePPDA();
      } catch(e){
        console.error(e);
        alert("Terjadi error saat AUTO-ESTIMATE PPDA. Cek input & console.");
      }
    });
  }
});
    const btnAutoPPDAext = document.getElementById('btn_auto_ppda_ext');
if (btnAutoPPDAext){
    btnAutoPPDAext.addEventListener('click', function(){
        try {
            autoPPDA_Extended();
        } catch(e){
            console.error(e);
            alert("Error pada AUTO PPDA EXTENDED. Cek input & console.");
        }
    });
    }
// =============================
// AUTO ESTIMATE PPDA EXTENDED
// =============================
function autoPPDA_Extended() {

    const styleH = document.getElementById("press_style_home").value;
    const styleA = document.getElementById("press_style_away").value;

    const xgaH = parseFloat(document.getElementById("adv_xga_home").value) || 1;
    const xgaA = parseFloat(document.getElementById("adv_xga_away").value) || 1;

    const errH = parseFloat(document.getElementById("def_error_home").value) || 0;
    const errA = parseFloat(document.getElementById("def_error_away").value) || 0;

    // Mapping gaya → PPDA dasar
    function mapPress(style){
        switch(style){
            case "extreme_high": return 5.0;
            case "gegenpress": return 7.0;
            case "hybrid_press": return 10.0;
            case "deep_low": return 20.0;
            case "man_marking_high": return 5.5;
            case "positional_high": return 7.5;
            case "semi_gegenpress": return 8.2;
            case "reactive_press": return 13.5;
            case "wing_press": return 14.5;
            case "inverted_press": return 10.0;
            case "zonal_midlow": return 17.5;
            case "ultra_compact": return 19.5;
            default: return null;
        }
    }

    // Estimasi PPDA
    let ppdaH = mapPress(styleH);
    let ppdaA = mapPress(styleA);

    if(ppdaH !== null){
        ppdaH -= (xgaA * 0.15);     // lawan banyak tembak → tekanan tinggi
        ppdaH += (errH * 0.40);     // error naik → PPDA naik
        document.getElementById("adv_ppda_home").value = ppdaH.toFixed(2);
    }

    if(ppdaA !== null){
        ppdaA -= (xgaH * 0.15);
        ppdaA += (errA * 0.40);
        document.getElementById("adv_ppda_away").value = ppdaA.toFixed(2);
    }

    // Auto push → press intensity (dipakai engine utama)
    if(ppdaH){
        document.getElementById("home_press").value = (12 - (ppdaH / 2)).toFixed(2);
    }
    if(ppdaA){
        document.getElementById("away_press").value = (12 - (ppdaA / 2)).toFixed(2);
    }

    // Output
    const out = document.getElementById("output");
    out.innerHTML += `
        <hr>
        <b>[AUTO PPDA EXTENDED]</b><br>
        PPDA Home: ${ppdaH ? ppdaH.toFixed(2) : "Manual"}<br>
        PPDA Away: ${ppdaA ? ppdaA.toFixed(2) : "Manual"}<br>
    `;
    }
  
// =============================================================
// PART 5 SELESAI — PRIME SINGULARITY ZERO ∑.REBUILD ENGINE COMPLETE
// =============================================================
</script>
<script>
// Helper aman
function numSafe(v){ const n = parseFloat(v); return isFinite(n) ? n : 0; }

/* ==========================
   ELITE+ ENVIRONMENT ENGINE
   ========================== */
function autoMatchElitePlus() {
  const ref  = numSafe(document.getElementById("ref_strict").value);
  const varS = document.getElementById("var_style").value || "normal";
  const stad = numSafe(document.getElementById("stadium_intensity").value);

  let tempoBoost = 0;
  let chaosBoost = 0;
  let cardRisk   = 0;

  // Wasit ketat → banyak foul & kartu → chaos naik, tempo turun sedikit
  cardRisk += ref * 1.2;
  chaosBoost += ref * 0.15;
  tempoBoost -= ref * 0.05;

  // VAR
  if (varS === "strict") {
    chaosBoost -= 0.1;  // permainan sedikit lebih "di-rem"
    cardRisk   += 1.0;
  } else if (varS === "lenient") {
    chaosBoost += 0.1;
    tempoBoost += 0.1;
  }

  // Stadium Intensity
  chaosBoost += stad * 0.1;
  tempoBoost += stad * 0.05;

  return {
    tempoBoost,
    chaosBoost,
    cardRisk
  };
}

function applyAutoElitePlus(){
  const res = autoMatchElitePlus();

  let tempo = numSafe(document.getElementById("tempo_input").value);
  let chaos = numSafe(document.getElementById("chaos_input").value);

  tempo += res.tempoBoost;
  chaos += res.chaosBoost;

  document.getElementById("tempo_input").value = tempo.toFixed(2);
  document.getElementById("chaos_input").value = chaos.toFixed(2);

  const out = document.getElementById("output");
  out.innerHTML += `
    <hr>
    <h3>[ELITE+ ENVIRONMENT]</h3>
    Ref & VAR Adjustment:<br>
    Tempo Boost: ${res.tempoBoost.toFixed(2)}<br>
    Chaos Boost: ${res.chaosBoost.toFixed(2)}<br>
    Card Risk Index: ${res.cardRisk.toFixed(1)}<br>
  `;
}

/* ==========================
   MANAGER TACTICS ENGINE
   ========================== */
function autoManagerTactics() {
  const risk   = numSafe(document.getElementById("coach_risk").value);
  const timing = document.getElementById("tactical_timing").value || "none";
  const bench  = numSafe(document.getElementById("bench_impact").value);

  let tempoBoost = 0;
  let chaosBoost = 0;
  let volatility = 0;
  let note       = "";

  // Coach risk → pertandingan lebih dinamis
  tempoBoost += risk * 0.15;
  chaosBoost += risk * 0.18;
  volatility += risk * 1.3;

  // Bench kuat → late swings
  chaosBoost += bench * 0.1;
  volatility += bench * 0.8;

  if (timing === "early") {
    note = "Kemungkinan perubahan taktik dini (awal babak 2).";
    chaosBoost += 0.2;
  } else if (timing === "mid") {
    note = "Perubahan taktik utama sekitar menit 60–75.";
    chaosBoost += 0.3;
  } else if (timing === "late") {
    note = "Perubahan taktik cenderung terlambat (75+).";
    volatility += 0.5;
  } else {
    note = "Pelatih cenderung menjaga struktur, jarang ubah taktik.";
  }

  return {
    tempoBoost,
    chaosBoost,
    volatility,
    note
  };
}

function applyManagerTactics(){
  const res = autoManagerTactics();

  let tempo = numSafe(document.getElementById("tempo_input").value);
  let chaos = numSafe(document.getElementById("chaos_input").value);

  tempo += res.tempoBoost;
  chaos += res.chaosBoost;

  document.getElementById("tempo_input").value = tempo.toFixed(2);
  document.getElementById("chaos_input").value = chaos.toFixed(2);

  const out = document.getElementById("output");
  out.innerHTML += `
    <hr>
    <h3>[MANAGER TACTICS]</h3>
    Tactical Volatility Index: ${res.volatility.toFixed(1)}<br>
    Tempo Boost: ${res.tempoBoost.toFixed(2)}<br>
    Chaos Boost: ${res.chaosBoost.toFixed(2)}<br>
    Note: ${res.note}<br>
  `;
}

/* ==========================
   GOAL FLOW MAP ENGINE
   ========================== */
function generateGoalFlowMap(){
  const tempo = numSafe(document.getElementById("tempo_input").value);
  const chaos = numSafe(document.getElementById("chaos_input").value);
  const imp   = numSafe(document.getElementById("importance_input").value);

  // Skala dasar peluang gol per 15 menit (belum dinormalisasi)
  // base pattern: 0–15 agak hati-hati, 15–45 naik, 45–60 spike, 60–90 tergantung chaos
  let seg = [1, 1.2, 1.3, 1.5, 1.4, 1.3]; // 0–15, 16–30, 31–45, 46–60, 61–75, 76–90

  // Tempo mempengaruhi semua segmen
  const tFactor = 1 + (tempo / 20);   // tempo 0–10 → faktor ~1–1.5
  // Chaos menaikkan bagian tengah & akhir
  const cFactor = 1 + (chaos / 15);   // chaos 0–10 → faktor ~1–1.7

  // Importance → gol sering muncul lebih lambat di awal jika penting
  const earlyDampen = imp >= 8 ? 0.8 : (imp >= 6 ? 0.9 : 1.0);

  let raw = [];
  for(let i=0;i<6;i++){
    let val = seg[i] * tFactor;
    if(i >= 2) val *= cFactor; // menit 31+ dipengaruhi chaos
    if(i === 0) val *= earlyDampen;
    raw.push(val);
  }

  // Normalisasi jadi persentase
  const sum = raw.reduce((a,b)=>a+b,0) || 1;
  const pct = raw.map(v => v / sum * 100);

  const labels = [
    "Menit 0–15",
    "Menit 16–30",
    "Menit 31–45",
    "Menit 46–60",
    "Menit 61–75",
    "Menit 76–90"
  ];

  let html = `<hr><h3>[GOAL FLOW MAP]</h3>`;
  html += `<small>Bukan prediksi pasti, hanya distribusi kecenderungan gol berdasarkan tempo/chaos/importance.</small><br><br>`;

  for(let i=0;i<6;i++){
    html += `${labels[i]} : ${pct[i].toFixed(1)}% potensi gol gabungan<br>`;
  }

  const out = document.getElementById("output");
  out.innerHTML += html;
}
</script>
  <script>
// ================
// 1. PPDA Mapping
// ================
function extendedPPDA(style){
  switch(style){
    case "extreme_high": return 5.0;
    case "gegenpress": return 7.0;
    case "hybrid_press": return 10.0;
    case "deep_low": return 20.0;

    case "man_marking_high": return 5.5;
    case "positional_high": return 7.5;
    case "semi_gegenpress": return 8.2;
    case "reactive_press": return 13.5;
    case "wing_press": return 14.5;
    case "inverted_press": return 10.0;
    case "zonal_midlow": return 17.5;
    case "ultra_compact": return 19.5;
    default: return null;
  }
}

// ================
// 2. Press Intensity (1–10)
// ================
// Rumus sederhana → PPDA rendah = intensitas tinggi.
function pressIntensityFromPPDA(ppda){
  if(!ppda) return 5;
  let PI = 12 - (ppda / 2);
  return Math.max(1, Math.min(10, PI));
}

// ================
// 3. Press Duel Index (baru)
// ================
// Mengukur benturan pressing antar tim.
function pressDuelIndex(p1, p2){
  let gap = Math.abs(p1 - p2);
  let total = p1 + p2;

  // total tinggi: duel agresif
  // gap besar: satu tim mendominasi pressing
  return {
    duel: total >= 14 ? "High Press Duel" :
           total >= 10 ? "Medium Duel" :
                          "Low Duel",

    dominance: gap >= 4 ? "One-Sided Pressing" :
                gap >= 2 ? "Mild Advantage" :
                           "Balanced"
  };
}

// ================
// 4. Pattern Oracle Booster (menghubungkan pressing ke gaya pertandingan)
// ================
function pressingToPatternStyle(p1, p2){
  const avg = (p1 + p2) / 2;

  if(avg >= 8) return "Chaos Transition Match";
  if(avg >= 6) return "High Tempo Vertical Match";
  if(avg >= 4) return "Structured High Press";
  if(avg >= 3) return "Mid-Block Tactical Match";
  return "Deep Block Slow Match";
}

// ================
// 5. MASTER PATCH: Pressing -> PPDA -> Intensity -> Pattern Oracle
// ================
function applyPressingFullSystem(){

  // Ambil gaya pressing
  const ph = document.getElementById("press_style_home").value;
  const pa = document.getElementById("press_style_away").value;

  const ppdaH = extendedPPDA(ph);
  const ppdaA = extendedPPDA(pa);

  // Jika user tidak memiliki PPDA asli → pakai pressing
  if(ppdaH !== null){
    document.getElementById("adv_ppda_home").value = ppdaH.toFixed(2);
  }
  if(ppdaA !== null){
    document.getElementById("adv_ppda_away").value = ppdaA.toFixed(2);
  }

  // Generate Press Intensity
  const piH = pressIntensityFromPPDA(ppdaH);
  const piA = pressIntensityFromPPDA(ppdaA);

  // Kirim ke input utama engine (home_press, away_press)
  document.getElementById("home_press").value = piH;
  document.getElementById("away_press").value = piA;

  // Duel Index
  const duel = pressDuelIndex(piH, piA);

  // Pattern Oracle Enhancement
  const matchStyle = pressingToPatternStyle(piH, piA);

  // Output
  const out = document.getElementById("output");
  out.innerHTML += `
    <hr><h3>[PRESSING FULL SYSTEM]</h3>
    <b>PPDA Home:</b> ${ppdaH}<br>
    <b>PPDA Away:</b> ${ppdaA}<br>
    <b>Press Intensity Home:</b> ${piH}<br>
    <b>Press Intensity Away:</b> ${piA}<br><br>

    <b>Duel Type:</b> ${duel.duel}<br>
    <b>Dominance:</b> ${duel.dominance}<br><br>

    <b>Pattern Oracle Style:</b> ${matchStyle}
  `;
}
    // ========== UI FIX: REMOVE DUPLICATE PRESSING OPTIONS ==========
function fixPressingUI() {
    const selects = [
        document.getElementById("press_style_home"),
        document.getElementById("press_style_away")
    ];

    selects.forEach(sel => {
        let seen = {};
        for (let i = sel.options.length - 1; i >= 0; i--) {
            const val = sel.options[i].value;
            if (seen[val]) sel.remove(i);
            else seen[val] = true;
        }
    });
}
fixPressingUI();
    // ========== PRESS DUEL INDEX REPORT ==========
function showPressDuel() {

    const hPI = parseFloat(document.getElementById("home_press").value) || 0;
    const aPI = parseFloat(document.getElementById("away_press").value) || 0;

    const gap = Math.abs(hPI - aPI);
    const total = hPI + aPI;

    let duelType =
        total >= 16 ? "ULTRA HIGH PRESS DUEL" :
        total >= 12 ? "HIGH PRESS DUEL" :
        total >= 8  ? "MID PRESS DUEL" :
                      "LOW PRESS DUEL";

    let dominance =
        gap >= 4 ? "Dominance: ONE SIDED" :
        gap >= 2 ? "Dominance: Slight Advantage" :
                   "Dominance: Balanced";

    const out = document.getElementById("output");

    out.innerHTML += `
        <hr><h3>[PRESS DUEL INDEX]</h3>
        Total Press Intensity: ${total}<br>
        Duel Type: <b>${duelType}</b><br>
        Gap: ${gap}<br>
        ${dominance}<br>
    `;
    }
    // ========== AUTO FLEX ESTIMATION ==========
function autoFlex() {

    const PIH = parseFloat(document.getElementById("home_press").value) || 5;
    const PIA = parseFloat(document.getElementById("away_press").value) || 5;

    const errH = parseFloat(document.getElementById("def_error_home").value) || 0;
    const errA = parseFloat(document.getElementById("def_error_away").value) || 0;

    const xgH = parseFloat(document.getElementById("adv_xg_home").value) || 1;
    const xgA = parseFloat(document.getElementById("adv_xg_away").value) || 1;

    const imp = parseFloat(document.getElementById("importance_input").value) || 5;

    const flexHome = (PIH * 0.25) + (errH * 0.2) + ((xgH - xgA) * 0.3) + (imp * 0.1);
    const flexAway = (PIA * 0.25) + (errA * 0.2) + ((xgA - xgH) * 0.3) + (imp * 0.1);

    document.getElementById("flex_home").value = flexHome.toFixed(2);
    document.getElementById("flex_away").value = flexAway.toFixed(2);

    document.getElementById("output").innerHTML += `
        <hr><h3>[AUTO FLEX]</h3>
        FLEX HOME: ${flexHome.toFixed(2)}<br>
        FLEX AWAY: ${flexAway.toFixed(2)}<br>
    `;
    }
    // ========== PRESSING HEATMAP ==========
// Simple ASCII visualization
function pressHeatmap(){

    const h = parseFloat(document.getElementById("home_press").value) || 5;
    const a = parseFloat(document.getElementById("away_press").value) || 5;

    function bar(v){
        return "█".repeat(Math.round(v));
    }

    const out = document.getElementById("output");

    out.innerHTML += `
        <hr><h3>[PRESSING HEATMAP]</h3>
        HOME: ${bar(h)} (${h})<br>
        AWAY: ${bar(a)} (${a})<br>
        <small>Semakin panjang bar → semakin tinggi intensitas pressing.</small>
    `;
    }
    // ========== MATCH ANALYSIS SUMMARY PRO ==========
function analysisSummary(){

    const PIH = parseFloat(document.getElementById("home_press").value);
    const PIA = parseFloat(document.getElementById("away_press").value);

    const chaos = parseFloat(document.getElementById("chaos_input").value);
    const tempo = parseFloat(document.getElementById("tempo_input").value);

    let matchType =
        chaos >= 7 ? "CHAOS MATCH" :
        tempo >= 7 ? "HIGH TEMPO MATCH" :
        chaos <= 3 ? "CONTROLLED / TACTICAL MATCH" :
                     "BALANCED GAME";

    const out = document.getElementById("output");
    out.innerHTML += `
        <hr><h3>[MATCH SUMMARY PRO]</h3>
        Match Type: <b>${matchType}</b><br>
        Home Press: ${PIH}<br>
        Away Press: ${PIA}<br>
        Chaos Level: ${chaos}<br>
        Tempo Level: ${tempo}<br>
        Interpretation: <i>${matchType} → pola permainan diprediksi sesuai metrik tempo/chaos.</i>
    `;
    }
    <!-- INFINITY CORE: GLOBAL SANITIZER -->
<script>
function INF_sanitize(value, fallback = 0){
    const v = parseFloat(value);
    if (isNaN(v) || v === undefined || v === null || !isFinite(v)) return fallback;
    return v;
}

// Auto-sanitize all number inputs (prevent NaN crashes)
function INF_autoSanitizeAll(){
    const inputs = document.querySelectorAll("input[type='number']");
    inputs.forEach(inp=>{
        inp.value = INF_sanitize(inp.value, 0);
    });
}
</script>
<script>
// INFINITY ACCURACY BOOSTER V3
function INF_accuracyBoost(lambdaH, lambdaA, chaos, tempo){

    const lh = INF_sanitize(lambdaH, 0.8);
    const la = INF_sanitize(lambdaA, 0.8);

    const c  = INF_sanitize(chaos, 1);
    const t  = INF_sanitize(tempo, 1);

    // Anti-overpredictor + anti-underpredictor
    const modifierH = 1 + ((t * 0.05) + (c * 0.08));
    const modifierA = 1 + ((t * 0.04) + (c * 0.06));

    // Scaled improvement
    return {
        home:  (lh * modifierH).toFixed(3),
        away:  (la * modifierA).toFixed(3)
    };
}
</script>  
  <script>
// INFINITY FORM MOMENTUM ENGINE
function INF_formMomentum(w, d, l){
    const win  = INF_sanitize(w, 0);
    const draw = INF_sanitize(d, 0);
    const lose = INF_sanitize(l, 0);

    const score = (win * 2.2) + (draw * 0.9) - (lose * 1.4);

    if(score >= 6) return {index: score, label: "High Momentum"};
    if(score >= 2) return {index: score, label: "Moderate Momentum"};
    if(score >= -1) return {index: score, label: "Neutral Momentum"};
    return {index: score, label: "Negative Momentum"};
}
  </script>
  <script>
// INFINITY TACTICAL SCENARIO AUTO-SWITCHER
function INF_autoScenario(tempo, chaos, pressH, pressA){

    const t = INF_sanitize(tempo);
    const c = INF_sanitize(chaos);
    const p = (INF_sanitize(pressH) + INF_sanitize(pressA)) / 2;

    if(t >= 7 && c >= 7) return "Exchange Battle";
    if(t >= 7 && c <  5) return "High Control Game";
    if(t <  5 && c >= 7) return "Disjointed Fight";
    if(t <  5 && c <  5) return "Low-Risk Tactical";
    if(p >= 7)           return "Pressing Duel";
    return "Balanced System Game";
}
               </script>
<script>
// INFINITY SCORELINE PROBABILITY ENGINE
function INF_scoreProbability(lambdaH, lambdaA, chaos){

    const lh = INF_sanitize(lambdaH);
    const la = INF_sanitize(lambdaA);
    const cz = INF_sanitize(chaos);

    const factor = (1 + (cz * 0.15));

    return {
        high:  (factor * ((lh + la)/2) * 0.32).toFixed(3),
        mid:   (factor * ((lh + la)/2) * 0.55).toFixed(3),
        low:   (factor * ((lh + la)/2) * 0.13).toFixed(3),
    };
}
</script>
  <script>
// INFINITY FINAL ENGINE LINKER
function INF_runInfinity(){

    // Sanitize all
    INF_autoSanitizeAll();

    const lambdaH = document.getElementById("lamH").value;
    const lambdaA = document.getElementById("lamA").value;

    const tempo  = document.getElementById("tempo").value;
    const chaos  = document.getElementById("chaos").value;

    const pressH = document.getElementById("home_press").value;
    const pressA = document.getElementById("away_press").value;

    const formH = INF_formMomentum(
        adv_form_home_w.value,
        adv_form_home_d.value,
        adv_form_home_l.value
    );

    const formA = INF_formMomentum(
        adv_form_away_w.value,
        adv_form_away_d.value,
        adv_form_away_l.value
    );

    const scoreBoost = INF_accuracyBoost(lambdaH, lambdaA, chaos, tempo);
    const scenario   = INF_autoScenario(tempo, chaos, pressH, pressA);
    const expected   = INF_scoreProbability(lambdaH, lambdaA, chaos);

    // OUTPUT
    const out = document.getElementById("output");
    out.innerHTML += `
    <hr><h3>[INFINITY ENGINE OUTPUT]</h3>
    Scenario: <b>${scenario}</b><br>
    Lambda Boost: H ${scoreBoost.home}, A ${scoreBoost.away}<br>
    Form Momentum: HOME ${formH.label}, AWAY ${formA.label}<br>
    Goal Probability (High/Mid/Low): ${expected.high} / ${expected.mid} / ${expected.low}<br>
    `;
}
  </script>
  <script>
// ===============================
// PRESSING FULL SYSTEM (INFINITY)
// ===============================
function runPressingFullSystem(){
    // Ambil gaya pressing
    const ph = document.getElementById("press_style_home").value;
    const pa = document.getElementById("press_style_away").value;

    // Ambil PPDA → kalau user sudah isi manual, pakai manual
    let ppdaH = parseFloat(document.getElementById("adv_ppda_home").value);
    let ppdaA = parseFloat(document.getElementById("adv_ppda_away").value);

    if(isNaN(ppdaH)){
        ppdaH = V20.estimatePPDAFromPressing(ph);
        document.getElementById("adv_ppda_home").value = ppdaH.toFixed(2);
    }
    if(isNaN(ppdaA)){
        ppdaA = V20.estimatePPDAFromPressing(pa);
        document.getElementById("adv_ppda_away").value = ppdaA.toFixed(2);
    }

    // Hitung press intensity
    const pressH = 12 - (ppdaH / 2);
    const pressA = 12 - (ppdaA / 2);

    document.getElementById("home_press").value = pressH.toFixed(2);
    document.getElementById("away_press").value = pressA.toFixed(2);

    // Output
    const out = document.getElementById("output");
    out.innerHTML += `
    <hr><h3>[PRESSING FULL SYSTEM]</h3>
    PPDA H: ${ppdaH.toFixed(2)} | Press Int: ${pressH.toFixed(2)}<br>
    PPDA A: ${ppdaA.toFixed(2)} | Press Int: ${pressA.toFixed(2)}<br>
    `;
}
 // Setelah PPDA selesai dihitung → Hitung Press Intensity otomatis
if(ppdaH){
    const pressH = pressIntensityFromPPDA(ppdaH);
    document.getElementById("home_press").value = pressH.toFixed(2);
}

if(ppdaA){
    const pressA = pressIntensityFromPPDA(ppdaA);
    document.getElementById("away_press").value = pressA.toFixed(2);
}

// Tambahkan log ke output
document.getElementById("output").innerHTML += `
<hr><h3>[AUTO PPDA EXTENDED]</h3>
PPDA Home: ${(ppdaH||0).toFixed(2)}<br>
PPDA Away: ${(ppdaA||0).toFixed(2)}<br>
Press H: ${pressIntensityFromPPDA(ppdaH).toFixed(2)}<br>
Press A: ${pressIntensityFromPPDA(ppdaA).toFixed(2)}<br>
`; 
</script>
  <script>
// ===========================
// AUTO MATCH DIFFICULTY v1.0
// ===========================
function autoMatchDifficulty(){

    const xgH = INF_sanitize(adv_xg_home.value, 1);
    const xgA = INF_sanitize(adv_xg_away.value, 1);

    const formH = INF_sanitize(adv_form_home_w.value*2 + adv_form_home_d.value - adv_form_home_l.value*2);
    const formA = INF_sanitize(adv_form_away_w.value*2 + adv_form_away_d.value - adv_form_away_l.value*2);

    const pressH = INF_sanitize(home_press.value, 6);
    const pressA = INF_sanitize(away_press.value, 6);

    const ratingH = (xgH * 0.4) + (formH * 0.3) + (pressH * 0.3);
    const ratingA = (xgA * 0.4) + (formA * 0.3) + (pressA * 0.3);

    const diff = ratingH - ratingA;

    let level = "Balanced";
    if(diff >= 4) level = "HOME Strong";
    if(diff <= -4) level = "AWAY Strong";
    if(diff >= 8) level = "HOME Dominant";
    if(diff <= -8) level = "AWAY Dominant";

    output.innerHTML += `
    <hr><h3>[MATCH DIFFICULTY]</h3>
    Home Rating: ${ratingH.toFixed(2)}<br>
    Away Rating: ${ratingA.toFixed(2)}<br>
    Difficulty: <b>${level}</b><br>
    `;
}
  </script>
  <script>
// ===============================================
// PRESSING → MATCH STYLE AUTO BLENDER v1.0
// ===============================================
function autoPressToMatchStyle(){

    const ph = INF_sanitize(home_press.value, 5);
    const pa = INF_sanitize(away_press.value, 5);

    const avg = (ph + pa) / 2;

    let style = "Balanced";

    if(avg >= 9) style = "Wild / Chaotic";
    else if(avg >= 7) style = "Fast Tempo";
    else if(avg >= 5) style = "Balanced Tempo";
    else if(avg >= 3) style = "Slow Tactical";
    else style = "Ultra Low Tempo";

    output.innerHTML += `
    <hr><h3>[PRESS → MATCH STYLE]</h3>
    Avg Press Intensity: ${avg.toFixed(2)}<br>
    Auto Style: <b>${style}</b><br>
    `;
}
  </script>
  <script>
// ============================
// SET PIECE POWER MODULE v1.0
// ============================
function setPiecePower(){

    const xg = INF_sanitize(adv_xg_home.value + adv_xg_away.value, 2);
    const chaos = INF_sanitize(chaos_input.value, 5);

    const sp = (xg * 0.3) + (chaos * 0.6);

    let label = "Normal";

    if(sp >= 12) label = "Very High Set-Piece Threat";
    else if(sp >= 9) label = "High Set-Piece Threat";
    else if(sp >= 6) label = "Medium Threat";
    else if(sp <= 3) label = "Low Threat";

    output.innerHTML += `
    <hr><h3>[SET PIECE PREDICTOR]</h3>
    Set-Piece Power Score: ${sp.toFixed(2)}<br>
    Threat Level: <b>${label}</b><br>
    `;
}
  </script>
  <script>
// =============================
// DYNAMIC MATCH FLOW v1.0
// =============================
function dynamicMatchFlow(){

    const tempo = INF_sanitize(tempo_input.value, 5);
    const chaos = INF_sanitize(chaos_input.value, 5);
    const press = INF_sanitize(
        (parseFloat(home_press.value)+parseFloat(away_press.value))/2, 
        5
    );

    const flow = (tempo * 0.4) + (chaos * 0.3) + (press * 0.3);

    let label = "Stable Control";
    if(flow >= 8) label = "Highly Volatile";
    else if(flow >= 6) label = "Dynamic";
    else if(flow >= 4) label = "Semi-Structured";

    output.innerHTML += `
    <hr><h3>[MATCH FLOW]</h3>
    Flow Index: ${flow.toFixed(2)}<br>
    Flow Type: <b>${label}</b><br>
    `;
}
  </script>
  <script>
// =============================
// DYNAMIC MATCH FLOW v1.0
// =============================
function dynamicMatchFlow(){

    const tempo = INF_sanitize(tempo_input.value, 5);
    const chaos = INF_sanitize(chaos_input.value, 5);
    const press = INF_sanitize(
        (parseFloat(home_press.value)+parseFloat(away_press.value))/2, 
        5
    );

    const flow = (tempo * 0.4) + (chaos * 0.3) + (press * 0.3);

    let label = "Stable Control";
    if(flow >= 8) label = "Highly Volatile";
    else if(flow >= 6) label = "Dynamic";
    else if(flow >= 4) label = "Semi-Structured";

    output.innerHTML += `
    <hr><h3>[MATCH FLOW]</h3>
    Flow Index: ${flow.toFixed(2)}<br>
    Flow Type: <b>${label}</b><br>
    `;
}
  </script>
  <script>
// ==============================
// TEAM TREND ANALYZER v1.0
// ==============================
function teamTrend(){

    const formH = INF_formMomentum(
        adv_form_home_w.value,
        adv_form_home_d.value,
        adv_form_home_l.value
    );

    const formA = INF_formMomentum(
        adv_form_away_w.value,
        adv_form_away_d.value,
        adv_form_away_l.value
    );

    output.innerHTML += `
    <hr><h3>[TEAM TREND]</h3>
    Home Trend: ${formH.label}<br>
    Away Trend: ${formA.label}<br>
    `;
}
      </script>
<script>
// ===============================
// ∑ OMEGA PRIME ENGINE – CORE
// ===============================

// Helper baca angka aman dengan beberapa kemungkinan ID
function OP_read(ids, fallback = 0){
    for (let i = 0; i < ids.length; i++){
        const el = document.getElementById(ids[i]);
        if(el){
            const v = parseFloat(el.value);
            if(!isNaN(v) && isFinite(v)) return v;
        }
    }
    return fallback;
}

// Helper tulis ke output
function OP_appendOutput(html){
    const out = document.getElementById("output");
    if(out){
        out.innerHTML += html;
    }
}

// INTI OMEGA PRIME
function OP_runOmegaPrime(){

    // --- Baca nilai inti dari engine utama ---
    const lamH   = OP_read(["lamH", "lambda_home"], 1.0);
    const lamA   = OP_read(["lamA", "lambda_away"], 1.0);

    const tempo  = OP_read(["tempo_input", "tempo"], 5);
    const chaos  = OP_read(["chaos_input", "chaos"], 5);
    const imp    = OP_read(["importance_input", "importance"], 5);

    const pressH = OP_read(["home_press"], 5);
    const pressA = OP_read(["away_press"], 5);

    const xgH    = OP_read(["adv_xg_home"], 1.2);
    const xgA    = OP_read(["adv_xg_away"], 1.0);
    const xgaH   = OP_read(["adv_xga_home"], 1.2);
    const xgaA   = OP_read(["adv_xga_away"], 1.0);

    const errH   = OP_read(["def_error_home"], 0);
    const errA   = OP_read(["def_error_away"], 0);

    // --- 1) Dominance Index (siapa lebih menguasai) ---
    const lamDiff   = lamH - lamA;
    const xgDiff    = xgH - xgA;
    const pressDiff = pressH - pressA;

    const domScore = (lamDiff * 1.4) + (xgDiff * 1.1) + (pressDiff * 0.7);

    let dominance = "Balanced";
    if(domScore >= 3)  dominance = "HOME Favoured";
    if(domScore >= 6)  dominance = "HOME Strong Favoured";
    if(domScore <= -3) dominance = "AWAY Favoured";
    if(domScore <= -6) dominance = "AWAY Strong Favoured";

    // --- 2) Volatility / Risk Index ---
    const avgErr   = (errH + errA) / 2;
    const avgXGA   = (xgaH + xgaA) / 2;
    const avgPress = (pressH + pressA) / 2;

    const riskIndex = 
        (chaos * 0.35) +
        (avgErr * 0.25) +
        (avgXGA * 0.15) +
        (avgPress * 0.15) +
        (imp * 0.10);

    let riskLabel = "Moderate Risk";
    if(riskIndex >= 14) riskLabel = "Extreme Risk / High Variance";
    else if(riskIndex >= 10) riskLabel = "High Risk / Swingy Match";
    else if(riskIndex <= 6) riskLabel = "Low Risk / Stable Match";

    // --- 3) Archetype Pertandingan (berdasar tempo, chaos, pressing) ---
    let archetype = "Balanced Tactical Game";
    const avgPressInt = avgPress;

    if(tempo >= 7 && chaos >= 7 && avgPressInt >= 7){
        archetype = "High Tempo • High Chaos • Pressing Battle";
    } else if(tempo >= 7 && chaos <= 4){
        archetype = "High Tempo • Controlled Structure";
    } else if(tempo <= 4 && chaos >= 7){
        archetype = "Slow Tempo • Chaotic / Error-Driven Match";
    } else if(tempo <= 4 && chaos <= 4){
        archetype = "Low Tempo • Compact Tactical Game";
    } else if(avgPressInt >= 7){
        archetype = "Aggressive Pressing / Transition Match";
    }

    // --- 4) Market Focus Suggestion (1X2 vs OU vs BTTS) ---
    const totalLam = lamH + lamA;
    let marketFocus = "Neutral / Mixed Market";

    if(totalLam >= 3 && chaos >= 6){
        marketFocus = "Stronger Edge di Over & BTTS Market";
    } else if(totalLam <= 2.2 && chaos <= 4){
        marketFocus = "Stronger Edge di Under & Correct Score";
    } else if(Math.abs(lamDiff) >= 0.6 && Math.abs(domScore) >= 3){
        marketFocus = "Stronger Edge di 1X2 / Handicap (dominance jelas)";
    }

    // --- 5) Confidence Tier (seberapa 'tajam' model) ---
    // Dasar: seberapa stabil (chaos rendah), error rendah, dominance jelas.
    let confidenceScore = 0;
    confidenceScore += (10 - Math.min(10, chaos)) * 0.8; // chaos rendah → +confidence
    confidenceScore += (10 - Math.min(10, avgErr * 2)) * 0.5;
    confidenceScore += Math.min(10, Math.abs(domScore)) * 0.4; // dominance besar → +confidence

    let confidenceTier = "Medium Confidence";
    if(confidenceScore >= 14) confidenceTier = "HIGH CONFIDENCE ZONE";
    else if(confidenceScore <= 7) confidenceTier = "LOW CONFIDENCE (hindari all-in)";

    // --- 6) Susun Output OMEGA PRIME ---
    OP_appendOutput(`
        <hr>
        <h2>∑ OMEGA PRIME – META ANALYSIS</h2>
        <b>Match Archetype:</b> ${archetype}<br>
        <b>Dominance:</b> ${dominance}<br>
        <b>Risk / Volatility:</b> ${riskLabel} (Index: ${riskIndex.toFixed(2)})<br>
        <b>Suggested Market Focus:</b> ${marketFocus}<br>
        <b>Confidence Tier:</b> ${confidenceTier}<br>
        <br>
        <b>Model Core Snapshot:</b><br>
        λH: ${lamH.toFixed(3)} | λA: ${lamA.toFixed(3)}<br>
        Tempo: ${tempo} | Chaos: ${chaos} | Importance: ${imp}<br>
        Press H/A: ${pressH.toFixed(2)} / ${pressA.toFixed(2)}<br>
        xG H/A: ${xgH.toFixed(2)} / ${xgA.toFixed(2)}<br>
        xGA H/A: ${xgaH.toFixed(2)} / ${xgaA.toFixed(2)}<br>
        Def Error H/A: ${errH} / ${errA}<br>
    `);
}
</script>
  <script>
// ======================================
// SINGULARITY ∞ INFINITE ENGINE - CORE
// ======================================

// Helper baca angka aman (multi ID fallback)
function SINF_read(ids, fallback = 0){
    for(let i=0;i<ids.length;i++){
        const el = document.getElementById(ids[i]);
        if(el){
            const v = parseFloat(el.value);
            if(!isNaN(v) && isFinite(v)) return v;
        }
    }
    return fallback;
}

// Helper tulis ke output
function SINF_out(html){
    const out = document.getElementById("output");
    if(out){
        out.innerHTML += html;
    }
}

// Model kecil internal untuk ensemble
function SINF_baseModel(lh, la){
    return {
        home: lh,
        away: la,
        total: lh + la
    };
}

function SINF_infinityModel(lh, la, tempo, chaos){
    const t = Math.max(0, Math.min(10, tempo));
    const c = Math.max(0, Math.min(10, chaos));

    const boostH = 1 + (t * 0.03) + (c * 0.04);
    const boostA = 1 + (t * 0.025) + (c * 0.035);

    const nh = lh * boostH;
    const na = la * boostA;

    return {
        home: nh,
        away: na,
        total: nh + na
    };
}

function SINF_riskAdjustedModel(lh, la, chaos, errH, errA, xgaH, xgaA){
    const c   = Math.max(0, Math.min(10, chaos));
    const err = (Math.max(0, errH) + Math.max(0, errA)) / 2;
    const xga = (Math.max(0, xgaH) + Math.max(0, xgaA)) / 2;

    let vol = (c * 0.4) + (err * 0.3) + (xga * 0.3);
    vol = Math.max(0, Math.min(20, vol));

    const factor = 1 + (vol / 50); // 0 →1.0 ; 20→1.4

    const nh = lh * factor;
    const na = la * factor;

    return {
        home: nh,
        away: na,
        total: nh + na,
        volIndex: vol
    };
}

// Hitung seberapa "sepakat" model2 ini
function SINF_engineAgreement(m1, m2, m3){
    const avgH = (m1.home + m2.home + m3.home) / 3;
    const avgA = (m1.away + m2.away + m3.away) / 3;

    const devH = (Math.abs(m1.home-avgH) + Math.abs(m2.home-avgH) + Math.abs(m3.home-avgH)) / 3;
    const devA = (Math.abs(m1.away-avgA) + Math.abs(m2.away-avgA) + Math.abs(m3.away-avgA)) / 3;

    const spread = devH + devA; // semakin besar → makin tidak sepakat
    const norm = Math.max(0, Math.min(4, spread)); // clamp

    const agreement = 100 - (norm / 4 * 100); // 0→100, 4→0
    return Math.max(0, Math.min(100, agreement));
}

// ===============================
// FUNGSI UTAMA ∞ ENGINE
// ===============================
function SINF_runInfiniteEngine(){

    // 1) Baca lambda dari engine utama
    const lamH  = SINF_read(["lamH", "lambda_home"], 1.0);
    const lamA  = SINF_read(["lamA", "lambda_away"], 1.0);

    // 2) Baca tempo / chaos / importance
    const tempo = SINF_read(["tempo_input", "tempo"], 5);
    const chaos = SINF_read(["chaos_input", "chaos"], 5);
    const imp   = SINF_read(["importance_input", "importance"], 5);

    // 3) Baca pressing
    const pressH = SINF_read(["home_press"], 5);
    const pressA = SINF_read(["away_press"], 5);

    // 4) Baca xG / xGA
    const xgH   = SINF_read(["adv_xg_home"], 1.2);
    const xgA   = SINF_read(["adv_xg_away"], 1.0);
    const xgaH  = SINF_read(["adv_xga_home"], 1.2);
    const xgaA  = SINF_read(["adv_xga_away"], 1.0);

    // 5) Baca error defensif
    const errH  = SINF_read(["def_error_home"], 0);
    const errA  = SINF_read(["def_error_away"], 0);

    // ======================
    // BANGUN 3 ENGINE MINI
    // ======================

    const base   = SINF_baseModel(lamH, lamA);
    const inf    = SINF_infinityModel(lamH, lamA, tempo, chaos);
    const riskM  = SINF_riskAdjustedModel(lamH, lamA, chaos, errH, errA, xgaH, xgaA);

    const agree  = SINF_engineAgreement(base, inf, riskM);

    // Ensembe final lambda = rata2
    const ensHome = (base.home + inf.home + riskM.home) / 3;
    const ensAway = (base.away + inf.away + riskM.away) / 3;
    const ensTot  = ensHome + ensAway;

    // ======================
    // Mode Risiko & Archetype
    // ======================

    let riskMode = "Normal Risk";
    if(riskM.volIndex >= 14) riskMode = "EXTREME VOLATILITY (High Swing)";
    else if(riskM.volIndex >= 9) riskMode = "HIGH VOLATILITY (Swingy)";

    let archetype = "Balanced Tactical Match";
    const avgPress = (pressH + pressA) / 2;

    if(tempo >= 7 && chaos >= 7 && avgPress >= 7){
        archetype = "Full-Throttle Chaos & Pressing Battle";
    } else if(tempo >= 7 && chaos <= 4){
        archetype = "High Tempo Structured Control";
    } else if(tempo <= 4 && chaos >= 7){
        archetype = "Slow Tempo But Error-Driven / Wild Moments";
    } else if(tempo <= 4 && chaos <= 4){
        archetype = "Low Tempo Compact Tactical Game";
    } else if(avgPress >= 7){
        archetype = "Aggressive Press & Transition-Heavy Game";
    }

    // ======================
    // Saran fokus market
    // ======================

    let market = "Neutral Market Mix (1X2 / OU / BTTS)";
    if(ensTot >= 3 && chaos >= 6){
        market = "Fokus: Over / BTTS / Goal Markets";
    } else if(ensTot <= 2.2 && chaos <= 4){
        market = "Fokus: Under / Correct Score / HT Markets";
    } else if(Math.abs(lamH - lamA) >= 0.6){
        market = "Fokus: 1X2 / Handicap / DNB (Dominance Edge)";
    }

    // ======================
    // Confidence dari sisi ∞
    // ======================

    let confLabel = "MEDIUM CONFIDENCE";
    if(agree >= 80 && riskM.volIndex <= 8){
        confLabel = "HIGH CONFIDENCE ZONE (Ensemble Sepakat & Risiko Terkontrol)";
    } else if(agree <= 50 || riskM.volIndex >= 14){
        confLabel = "LOW CONFIDENCE (Engine Tidak Kompak / Volatilitas Tinggi)";
    }

    // ======================
    // TULIS KE OUTPUT
    // ======================

    SINF_out(`
        <hr>
        <h2>Singularity ∞ Infinite Engine – Ensemble Meta</h2>
        <b>∞ Archetype:</b> ${archetype}<br>
        <b>∞ Risk Mode:</b> ${riskMode} (Volatility Index: ${riskM.volIndex.toFixed(2)})<br>
        <b>∞ Engine Agreement Index:</b> ${agree.toFixed(1)} / 100<br>
        <b>∞ Ensemble λ:</b> Home ${ensHome.toFixed(3)} | Away ${ensAway.toFixed(3)} | Total ${ensTot.toFixed(3)}<br>
        <b>∞ Suggested Market Focus:</b> ${market}<br>
        <b>∞ Confidence Tier:</b> ${confLabel}<br>
        <br>
        <b>Core Snapshot:</b><br>
        λH/λA: ${lamH.toFixed(3)} / ${lamA.toFixed(3)}<br>
        Tempo/Chaos/Imp: ${tempo} / ${chaos} / ${imp}<br>
        Press H/A: ${pressH.toFixed(2)} / ${pressA.toFixed(2)}<br>
        xG H/A: ${xgH.toFixed(2)} / ${xgA.toFixed(2)}<br>
        xGA H/A: ${xgaH.toFixed(2)} / ${xgaA.toFixed(2)}<br>
        Def Error H/A: ${errH} / ${errA}<br>
    `);
}
</script>
  <script>
// ==================================
// FATE COLLAPSE ENGINE – BIG MATCH
// ==================================

// Helper kecil khusus Fate
function FATE_read(id, fallback = 0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    const v = parseFloat(el.value);
    if(isNaN(v) || !isFinite(v)) return fallback;
    return v;
}

function FATE_out(html){
    const out = document.getElementById("output");
    if(out) out.innerHTML += html;
}

// Engine utama Fate Collapse
function FATE_runFateCollapse(){

    // Importance & konteks dasar
    const imp   = FATE_read("importance_input", 5);
    const tempo = FATE_read("tempo_input", 5);
    const chaos = FATE_read("chaos_input", 5);

    // Form (W-D-L) untuk momentum besar
    const fwH = FATE_read("adv_form_home_w", 0);
    const fdH = FATE_read("adv_form_home_d", 0);
    const flH = FATE_read("adv_form_home_l", 0);

    const fwA = FATE_read("adv_form_away_w", 0);
    const fdA = FATE_read("adv_form_away_d", 0);
    const flA = FATE_read("adv_form_away_l", 0);

    const formIndexH = (fwH * 2.3) + (fdH * 0.8) - (flH * 1.7);
    const formIndexA = (fwA * 2.3) + (fdA * 0.8) - (flA * 1.7);
    const formGap    = formIndexH - formIndexA;

    // Press & error & xGA
    const pressH = FATE_read("home_press", 5);
    const pressA = FATE_read("away_press", 5);
    const avgPress = (pressH + pressA) / 2;

    const errH  = FATE_read("def_error_home", 0);
    const errA  = FATE_read("def_error_away", 0);
    const avgErr = (errH + errA) / 2;

    const xgaH = FATE_read("adv_xga_home", 1);
    const xgaA = FATE_read("adv_xga_away", 1);
    const avgXGA = (xgaH + xgaA) / 2;

    // Lambda dasar
    const lamH = FATE_read("lamH", 1.0);
    const lamA = FATE_read("lamA", 1.0);
    const lamDiff = lamH - lamA;

    // ============================
    // 1) Hitung "Big Match Factor"
    // ============================
    // Importance tinggi + tempo tinggi + chaos tinggi → peluang anomali naik
    let bigMatchFactor = 0;
    bigMatchFactor += imp * 1.2;
    bigMatchFactor += tempo * 0.4;
    bigMatchFactor += chaos * 0.7;

    // ============================
    // 2) Hitung "Collapse Potential"
    // ============================
    // Jika salah satu tim jauh lebih kuat, tapi chaos + error tinggi → peluang "kejatuhan raksasa"
    const strengthGap = (lamDiff * 1.6) + (formGap * 0.4);
    const volatility  = (chaos * 0.7) + (avgErr * 1.1) + (avgXGA * 0.6);

    const collapseScore = (Math.abs(strengthGap) * 0.6) + (volatility * 1.1) + (bigMatchFactor * 0.3);

    // Normalisasi ke 0–100
    let collapseIndex = collapseScore;
    if(collapseIndex < 0) collapseIndex = 0;
    if(collapseIndex > 100) collapseIndex = 100;

    // ============================
    // 3) Label skenario
    // ============================
    let fateLabel = "Normal Competitive Match (anomali kecil)";
    if(collapseIndex >= 65) fateLabel = "High Fate Collapse Risk (Big Upset / Skor Aneh Berpotensi)";
    else if(collapseIndex >= 45) fateLabel = "Elevated Fate Risk (Upset / Swing Besar Mungkin Terjadi)";
    else if(collapseIndex <= 25) fateLabel = "Low Fate Risk (model cenderung stabil)";

    // "Arah" collapse (HOME jatuh atau AWAY jatuh)
    let collapseSide = "Tidak condong (bisa ke dua arah)";
    if(strengthGap >= 4) collapseSide = "Jika collapse terjadi: potensi kejutan MELAWAN HOME (tim besar gagal)";
    else if(strengthGap <= -4) collapseSide = "Jika collapse terjadi: potensi kejutan MELAWAN AWAY (away favorit gagal)";

    // ============================
    // 4) Output Fate Collapse
    // ============================
    FATE_out(`
        <hr>
        <h2>FATE COLLAPSE ENGINE – BIG MATCH ANOMALY</h2>
        <b>Fate Risk Level:</b> ${fateLabel}<br>
        <b>Fate Collapse Index:</b> ${collapseIndex.toFixed(1)} / 100<br>
        <b>Collapse Direction:</b> ${collapseSide}<br>
        <br>
        <b>Context Snapshot:</b><br>
        Importance: ${imp} | Tempo: ${tempo} | Chaos: ${chaos}<br>
        Avg Press: ${avgPress.toFixed(2)} | Avg Def Error: ${avgErr.toFixed(2)} | Avg xGA: ${avgXGA.toFixed(2)}<br>
        λH/λA: ${lamH.toFixed(3)} / ${lamA.toFixed(3)} (Gap: ${lamDiff.toFixed(3)})<br>
        Form Index H/A: ${formIndexH.toFixed(2)} / ${formIndexA.toFixed(2)} (Gap: ${formGap.toFixed(2)})<br>
    `);
}
  </script>
  <script>
// ========================================
// GRAND UNIFIED ENGINE – META EXECUTOR
// ========================================

function GUN_read(id, fallback = 0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    const v = parseFloat(el.value);
    if(isNaN(v) || !isFinite(v)) return fallback;
    return v;
}

function GUN_out(html){
    const out = document.getElementById("output");
    if(out) out.innerHTML += html;
}

function GUN_runGrandUnified(){

    // 1) Jalankan sanitizer kalau ada
    if(typeof INF_autoSanitizeAll === "function"){
        INF_autoSanitizeAll();
    }

    // 2) Panggil engine utama yang ada (tidak error kalau belum ada)
    if(typeof V20 !== "undefined" && typeof V20.runPrimeZero === "function"){
        V20.runPrimeZero();
    }
    if(typeof INF_runInfinity === "function"){
        INF_runInfinity();
    }
    if(typeof OP_runOmegaPrime === "function"){
        OP_runOmegaPrime();
    }
    if(typeof SINF_runInfiniteEngine === "function"){
        SINF_runInfiniteEngine();
    }
    if(typeof FATE_runFateCollapse === "function"){
        FATE_runFateCollapse();
    }

    // 3) Grand Summary singkat berdasarkan nilai setelah semua engine jalan
    const lamH  = GUN_read("lamH", 1.0);
    const lamA  = GUN_read("lamA", 1.0);
    const tempo = GUN_read("tempo_input", 5);
    const chaos = GUN_read("chaos_input", 5);
    const pressH = GUN_read("home_press", 5);
    const pressA = GUN_read("away_press", 5);

    const totalLam = lamH + lamA;
    const avgPress = (pressH + pressA) / 2;

    let overallMode = "Balanced & Normal Risk";
    if(chaos >= 7 && totalLam >= 3){
        overallMode = "High Scoring • Chaotic • Volatile";
    } else if(chaos <= 4 && totalLam <= 2.2){
        overallMode = "Low Scoring • Tactical • Compact";
    } else if(avgPress >= 7 && tempo >= 7){
        overallMode = "Fast Tempo Pressing War";
    }

    GUN_out(`
        <hr>
        <h2>GRAND UNIFIED ENGINE – FINAL OVERVIEW</h2>
        <b>Overall Match Mode:</b> ${overallMode}<br>
        Total λ (Goals): ${totalLam.toFixed(3)}<br>
        Tempo / Chaos: ${tempo} / ${chaos}<br>
        Avg Press Intensity: ${avgPress.toFixed(2)}<br>
        <small>Semua engine (Prime / Infinity / Omega / ∞ / Fate) telah dieksekusi bila tersedia.</small>
    `);
}
  </script>
  <script>
// ===================================================
// UNIVERSAL FALLBACK FUNCTION PACK
// Mengaktifkan tombol-tombol lama yang belum punya fungsi
// Semua fungsi aman, tidak menimpa engine utama
// ===================================================

// 1) Ringkasan analisis akhir (simple)
function analysisSummary(){
    const lamH = parseFloat(lamH?.value) || 0;
    const lamA = parseFloat(lamA?.value) || 0;
    const tempo = parseFloat(tempo_input?.value) || 0;
    const chaos = parseFloat(chaos_input?.value) || 0;
    const pressH = parseFloat(home_press?.value) || 0;
    const pressA = parseFloat(away_press?.value) || 0;

    output.innerHTML += `
        <hr><h3>ANALYSIS SUMMARY</h3>
        λ Home/Away: ${lamH} / ${lamA}<br>
        Tempo/Chaos: ${tempo} / ${chaos}<br>
        Press: ${pressH} / ${pressA}<br>
    `;
}

// 2) Pressing Full System (fallback sederhana)
function applyPressingFullSystem(){
    const ph = parseFloat(home_press?.value) || 0;
    const pa = parseFloat(away_press?.value) || 0;

    output.innerHTML += `
        <hr><h3>PRESSING FULL SYSTEM</h3>
        Press Home: ${ph}<br>
        Press Away: ${pa}<br>
    `;
}

// 3) Heatmap Pressing
function pressHeatmap(){
    const h = parseFloat(home_press?.value) || 0;
    const a = parseFloat(away_press?.value) || 0;

    const bar = v => "█".repeat(Math.max(1, Math.round(v)));

    output.innerHTML += `
        <hr><h3>PRESS HEATMAP</h3>
        Home: ${bar(h)} (${h})<br>
        Away: ${bar(a)} (${a})<br>
    `;
}

// 4) Manager Tactical Suggestion
function applyManagerTactics(){
    const tempo = parseFloat(tempo_input?.value) || 0;
    const chaos = parseFloat(chaos_input?.value) || 0;

    let plan = "Standard Approach";
    if(tempo >= 7 && chaos >= 7) plan = "High Press + Vertical Attack";
    else if(tempo <= 4 && chaos <= 4) plan = "Compact Block + Build-Up";
    else if(tempo >= 7 && chaos <= 5) plan = "Structured High Tempo";
    
    output.innerHTML += `
        <hr><h3>MANAGER TACTICS</h3>
        Recommended Plan: <b>${plan}</b><br>
    `;
}

// 5) Elite Environment Analyzer
function autoEliteEnv(){
    const imp = parseFloat(importance_input?.value) || 5;
    const chaos = parseFloat(chaos_input?.value) || 5;

    const eliteScore = (imp * 1.4) + (chaos * 0.8);

    output.innerHTML += `
        <hr><h3>ELITE ENVIRONMENT</h3>
        Elite Score: ${eliteScore.toFixed(2)}<br>
        Level: ${eliteScore >= 14 ? "ELITE MATCH" : "NORMAL MATCH"}<br>
    `;
}

// 6) Goal Flow Map (simple)
function goalFlowMap(){
    const lamH = parseFloat(lamH?.value) || 1;
    const lamA = parseFloat(lamA?.value) || 1;

    output.innerHTML += `
        <hr><h3>GOAL FLOW MAP</h3>
        Home Scoring Curve: ${(lamH*1.2).toFixed(2)}<br>
        Away Scoring Curve: ${(lamA*1.2).toFixed(2)}<br>
    `;
}

// 7) Summary Match (fallback)
function runMatchSummary(){
    const tempo = parseFloat(tempo_input?.value) || 0;
    const chaos = parseFloat(chaos_input?.value) || 0;

    output.innerHTML += `
        <hr><h3>MATCH SUMMARY</h3>
        Tempo: ${tempo}<br>
        Chaos: ${chaos}<br>
    `;
}

// 8) Press Duel
function runPressDuelIndex(){
    const ph = parseFloat(home_press?.value) || 0;
    const pa = parseFloat(away_press?.value) || 0;
    const diff = ph - pa;

    output.innerHTML += `
        <hr><h3>PRESS DUEL INDEX</h3>
        Duel Gap: ${diff.toFixed(2)}<br>
        Winner: ${diff > 0 ? "HOME" : diff < 0 ? "AWAY" : "BALANCED"}<br>
    `;
}

// 9) Advanced Style
function advancedMatchStyle(){
    const tempo = parseFloat(tempo_input?.value) || 0;
    let style = "Balanced";
    if(tempo >= 7) style = "Fast";
    else if(tempo <= 4) style = "Slow";

    output.innerHTML += `
        <hr><h3>ADVANCED MATCH STYLE</h3>
        Style: ${style}<br>
    `;
}

// 10) Team Behavior
function autoTeamProfile(){
    const pressH = parseFloat(home_press?.value) || 0;
    const pressA = parseFloat(away_press?.value) || 0;

    output.innerHTML += `
        <hr><h3>TEAM PROFILE</h3>
        Home: ${pressH >= 6 ? "High Press" : "Normal"}<br>
        Away: ${pressA >= 6 ? "High Press" : "Normal"}<br>
    `;
}

// 11) Phase Predictor
function autoPhasePredictor(){
    const chaos = parseFloat(chaos_input?.value) || 0;
    const phase = chaos >= 6 ? "Volatile Mid-game" : "Stable Build-up";

    output.innerHTML += `
        <hr><h3>MATCH PHASE PREDICTOR</h3>
        Phase: ${phase}<br>
    `;
}
  </script>
  <script>
// ===================================================
// HELPER KHUSUS ENGINE BARU (AMAN, TIDAK TUMPANG TINDIH)
// ===================================================
function UIE_safeRead(id, fallback = 0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    const v = parseFloat(el.value);
    if(isNaN(v) || !isFinite(v)) return fallback;
    return v;
}

function UIE_safeOut(html){
    const out = document.getElementById("output");
    if(out) out.innerHTML += html;
}

// ===================================================
// 1) QUANTUM REALITY ENGINE (QRE_)
//    - Membentuk 3 "realitas": Conservative, Base, Wild
// ===================================================
function QRE_runQuantumReality(){

    const lamH  = UIE_safeRead("lamH", 1.0);
    const lamA  = UIE_safeRead("lamA", 1.0);
    const tempo = UIE_safeRead("tempo_input", 5);
    const chaos = UIE_safeRead("chaos_input", 5);
    const imp   = UIE_safeRead("importance_input", 5);

    // Realitas 1: Conservative (defensif, final stage match)
    const consFactor = 1 - Math.min(0.25, (imp * 0.02) + (chaos * 0.01));
    const consH = lamH * consFactor;
    const consA = lamA * consFactor;

    // Realitas 2: Base (normal, sesuai model utama)
    const baseH = lamH;
    const baseA = lamA;

    // Realitas 3: Wild (over-shoot, chaos tinggi)
    const wildFactor = 1 + Math.min(0.5, (tempo * 0.04) + (chaos * 0.06));
    const wildH = lamH * wildFactor;
    const wildA = lamA * wildFactor;

    UIE_safeOut(`
        <hr>
        <h2>QUANTUM REALITY ENGINE</h2>
        <b>Conservative Reality (Tight / Under Lean)</b><br>
        λH/λA: ${consH.toFixed(3)} / ${consA.toFixed(3)}<br><br>

        <b>Base Reality (Model Sekarang)</b><br>
        λH/λA: ${baseH.toFixed(3)} / ${baseA.toFixed(3)}<br><br>

        <b>Wild Reality (High Chaos / High Goals)</b><br>
        λH/λA: ${wildH.toFixed(3)} / ${wildA.toFixed(3)}<br><br>

        <small>Gunakan untuk melihat spektrum kemungkinan: dari tight sampai wild game.</small>
    `);
}

// ===================================================
// 2) META NARRATIVE ENGINE (MNE_)
//    - Baca importance, form gap, "big game feel"
// ===================================================
function MNE_runMetaNarrative(){

    const imp   = UIE_safeRead("importance_input", 5);
    const tempo = UIE_safeRead("tempo_input", 5);
    const chaos = UIE_safeRead("chaos_input", 5);

    const fwH = UIE_safeRead("adv_form_home_w", 0);
    const fdH = UIE_safeRead("adv_form_home_d", 0);
    const flH = UIE_safeRead("adv_form_home_l", 0);

    const fwA = UIE_safeRead("adv_form_away_w", 0);
    const fdA = UIE_safeRead("adv_form_away_d", 0);
    const flA = UIE_safeRead("adv_form_away_l", 0);

    const formH = (fwH * 2.3) + (fdH * 0.9) - (flH * 1.8);
    const formA = (fwA * 2.3) + (fdA * 0.9) - (flA * 1.8);
    const formGap = formH - formA;

    // Narrative Tilt
    let narrativeTilt = "Netral (tidak condong)";
    if(formGap >= 4) narrativeTilt = "Narrative condong ke HOME (tim on-fire, momentum fans, hype tinggi)";
    else if(formGap <= -4) narrativeTilt = "Narrative condong ke AWAY (underdog kuat / giant killer mode)";

    // Emotional Intensity dari importance + tempo + chaos
    const emoScore = (imp * 1.5) + (tempo * 0.7) + (chaos * 0.8);
    let emoLabel = "Normal Emotional Intensity";
    if(emoScore >= 26) emoLabel = "Extreme Emotional Game (derby / final / tekanan besar)";
    else if(emoScore >= 18) emoLabel = "High Emotional Intensity (laga panas / tensi tinggi)";
    else if(emoScore <= 10) emoLabel = "Cool / Calm Match (tekanan psikologis relatif rendah)";

    UIE_safeOut(`
        <hr>
        <h2>META NARRATIVE ENGINE</h2>
        <b>Narrative Tilt:</b> ${narrativeTilt}<br>
        <b>Emotional Intensity:</b> ${emoLabel}<br>
        <b>Form Index H/A:</b> ${formH.toFixed(2)} / ${formA.toFixed(2)} (Gap: ${formGap.toFixed(2)})<br>
        <b>Importance/Tempo/Chaos:</b> ${imp} / ${tempo} / ${chaos}<br>
        <small>Meta Narrative = cerita di balik pertandingan: momentum, hype, tekanan mental.</small>
    `);
}

// ===================================================
// 3) AI FORMATION ADAPTATION (AIF_)
//    - Pakai fleksibilitas, pressing, chaos → behavior formasi
// ===================================================
function AIF_runFormationAI(){

    // Flex bisa dari beberapa ID yang mungkin kamu pakai
    const flexH = UIE_safeRead("home_flex", UIE_safeRead("flex_home", 5));
    const flexA = UIE_safeRead("away_flex", UIE_safeRead("flex_away", 5));

    const pressH = UIE_safeRead("home_press", 5);
    const pressA = UIE_safeRead("away_press", 5);

    const chaos  = UIE_safeRead("chaos_input", 5);
    const tempo  = UIE_safeRead("tempo_input", 5);

    // Prediksi adaptasi saat unggul / tertinggal
    function predictBehavior(flex, press, sideLabel){
        let whenLeading = "Menjaga struktur dasar, sedikit lebih solid.";
        let whenLosing  = "Naik garis sedikit, namun tidak liar.";

        if(flex >= 7 && press >= 6){
            whenLeading = "Bisa turun ke blok lebih rendah, tapi tetap siap pressing transisi.";
            whenLosing  = "Berani naik garis, ubah formasi lebih ofensif (misal tambah striker).";
        } else if(flex <= 4){
            whenLeading = "Cenderung parkir bus / menumpuk lini belakang.";
            whenLosing  = "Sulit adaptasi formasi, lebih mengandalkan individu.";
        }

        if(chaos >= 7){
            whenLeading += " Chaos tinggi → risiko kebobolan balasan tetap ada.";
            whenLosing  += " Chaos tinggi → bisa tercipta comeback tidak terduga.";
        }

        return `
            <b>${sideLabel}</b><br>
            Saat unggul: ${whenLeading}<br>
            Saat tertinggal: ${whenLosing}<br><br>
        `;
    }

    const behHome = predictBehavior(flexH, pressH, "HOME");
    const behAway = predictBehavior(flexA, pressA, "AWAY");

    UIE_safeOut(`
        <hr>
        <h2>AI FORMATION ADAPTATION</h2>
        Flex HOME/AWAY: ${flexH.toFixed(1)} / ${flexA.toFixed(1)}<br>
        Press HOME/AWAY: ${pressH.toFixed(1)} / ${pressA.toFixed(1)}<br>
        Tempo/Chaos: ${tempo} / ${chaos}<br><br>
        ${behHome}
        ${behAway}
        <small>Interpretasi: bagaimana kemungkinan pelatih mengubah formasi saat unggul / tertinggal.</small>
    `);
}

// ===================================================
// 4) UNITED INTELLIGENCE ENGINE (UIE_)
//    - Mengumpulkan Quantum, Meta, Formation, Omega, Singularity, Fate
// ===================================================
function UIE_runUnitedIntelligence(){

    // Jalankan engine lain kalau ada
    if(typeof QRE_runQuantumReality === "function"){
        QRE_runQuantumReality();
    }
    if(typeof MNE_runMetaNarrative === "function"){
        MNE_runMetaNarrative();
    }
    if(typeof AIF_runFormationAI === "function"){
        AIF_runFormationAI();
    }
    if(typeof OP_runOmegaPrime === "function"){
        OP_runOmegaPrime();
    }
    if(typeof SINF_runInfiniteEngine === "function"){
        SINF_runInfiniteEngine();
    }
    if(typeof FATE_runFateCollapse === "function"){
        FATE_runFateCollapse();
    }
    if(typeof GUN_runGrandUnified === "function"){
        GUN_runGrandUnified();
    }

    // Buat meta-resume singkat di akhir
    const lamH  = UIE_safeRead("lamH", 1.0);
    const lamA  = UIE_safeRead("lamA", 1.0);
    const tempo = UIE_safeRead("tempo_input", 5);
    const chaos = UIE_safeRead("chaos_input", 5);
    const pressH = UIE_safeRead("home_press", 5);
    const pressA = UIE_safeRead("away_press", 5);

    const totalLam = lamH + lamA;
    const avgPress = (pressH + pressA) / 2;

    let verdict = "Pertandingan cenderung seimbang dengan risiko standar.";
    if(totalLam >= 3 && chaos >= 7){
        verdict = "Game cenderung liar, banyak gol, hasil bisa swing. Jaga money management.";
    } else if(totalLam <= 2.2 && chaos <= 4){
        verdict = "Game cenderung ketat & taktis. Nilai ada di under / skor kecil / arah 1X2 yang jelas.";
    } else if(Math.abs(lamH - lamA) >= 0.7){
        verdict = "Model multi-engine melihat sisi yang cukup dominan. Bisa dilirik di 1X2 / handicap.";
    }

    UIE_safeOut(`
        <hr>
        <h2>UNITED INTELLIGENCE ENGINE – FINAL META</h2>
        <b>United Verdict:</b> ${verdict}<br>
        Total λ: ${totalLam.toFixed(3)} | Tempo/Chaos: ${tempo} / ${chaos}<br>
        Avg Press: ${avgPress.toFixed(2)}<br>
        <small>UIE menggabungkan Quantum, Meta, Formation, Omega, ∞, Fate, dan Grand Unified bila tersedia.</small>
    `);
}
  </script>
  <script>
// ========================================
// DIMENSIONAL ENGINE HELPERS (AMAN)
// ========================================
function DIM_read(id, fallback = 0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    const v = parseFloat(el.value);
    if(isNaN(v) || !isFinite(v)) return fallback;
    return v;
}

function DIM_out(html){
    const out = document.getElementById("output");
    if(out) out.innerHTML += html;
}

// ========================================
// 1) HRE_ – HYPER-REALITY ENGINE
//    5 realitas: Tight, Normal, Wild, Collapse, Tactical
// ========================================
function HRE_runHyperReality(){

    const lamH  = DIM_read("lamH", 1.0);
    const lamA  = DIM_read("lamA", 1.0);
    const tempo = DIM_read("tempo_input", 5);
    const chaos = DIM_read("chaos_input", 5);
    const imp   = DIM_read("importance_input", 5);

    const baseH = lamH;
    const baseA = lamA;

    const tightFactor   = 1 - Math.min(0.3, (imp*0.02) + (chaos*0.015));
    const wildFactor    = 1 + Math.min(0.6, (tempo*0.05) + (chaos*0.07));
    const tacticalFactor= 1 - Math.min(0.25, (tempo*0.02)) + (imp*0.015);

    const tightH = baseH * tightFactor;
    const tightA = baseA * tightFactor;

    const wildH  = baseH * wildFactor;
    const wildA  = baseA * wildFactor;

    const tactH  = baseH * tacticalFactor;
    const tactA  = baseA * tacticalFactor;

    // Collapse reality → gol bisa sangat beda karena meltdown
    const collapseBoost = 1 + Math.min(0.9, (chaos*0.09) + (imp*0.04));
    const collapseH = baseH * collapseBoost;
    const collapseA = baseA * collapseBoost;

    DIM_out(`
        <hr>
        <h2>HRE – HYPER REALITY ENGINE</h2>
        <b>1) Tight Reality:</b> λH/λA = ${tightH.toFixed(3)} / ${tightA.toFixed(3)}<br>
        <b>2) Base Reality:</b> λH/λA = ${baseH.toFixed(3)} / ${baseA.toFixed(3)}<br>
        <b>3) Wild Reality:</b> λH/λA = ${wildH.toFixed(3)} / ${wildA.toFixed(3)}<br>
        <b>4) Collapse Reality:</b> λH/λA = ${collapseH.toFixed(3)} / ${collapseA.toFixed(3)}<br>
        <b>5) Tactical Reality:</b> λH/λA = ${tactH.toFixed(3)} / ${tactA.toFixed(3)}<br>
        <small>Gunakan untuk melihat spektrum result dari paling ketat sampai paling liar.</small>
    `);
}

// ========================================
// 2) GOE_ – GENETIC OUTCOME ENGINE (versi ringan)
//    Evolusi sederhana λ dalam beberapa "generasi"
// ========================================
function GOE_runGeneticOutcome(){

    let lamH = DIM_read("lamH", 1.0);
    let lamA = DIM_read("lamA", 1.0);

    const chaos = DIM_read("chaos_input", 5);
    const errH  = DIM_read("def_error_home", 0);
    const errA  = DIM_read("def_error_away", 0);

    const generations = 5;
    let history = [];

    for(let g=1; g<=generations; g++){
        const noiseH = (Math.random() - 0.5) * (chaos*0.08 + errA*0.04);
        const noiseA = (Math.random() - 0.5) * (chaos*0.08 + errH*0.04);

        lamH = Math.max(0.1, lamH + noiseH);
        lamA = Math.max(0.1, lamA + noiseA);

        history.push(`Gen ${g}: λH/λA = ${lamH.toFixed(3)} / ${lamA.toFixed(3)}`);
    }

    DIM_out(`
        <hr>
        <h2>GOE – GENETIC OUTCOME ENGINE</h2>
        ${history.join("<br>")}
        <br><small>Simulasi evolusi sederhana berbasis chaos & error untuk melihat variasi potensi skor.</small>
    `);
}

// ========================================
// 3) CFM_ – CHAOS FRACTAL MODEL
//    Fractal Predictability Index (0–100)
// ========================================
function CFM_runChaosFractal(){

    const chaos = DIM_read("chaos_input", 5);
    const errH  = DIM_read("def_error_home", 0);
    const errA  = DIM_read("def_error_away", 0);
    const pressH= DIM_read("home_press", 5);
    const pressA= DIM_read("away_press", 5);

    const avgErr   = (errH + errA) / 2;
    const avgPress = (pressH + pressA) / 2;

    let fractalNoise = (chaos*1.7) + (avgErr*1.4) + (avgPress*0.9);
    fractalNoise = Math.max(0, Math.min(40, fractalNoise));

    const predictability = 100 - (fractalNoise / 40 * 100);

    let label = "Moderate Readability";
    if(predictability >= 70) label = "High Predictability (model mudah membaca match)";
    else if(predictability <= 35) label = "Low Predictability (fraktal chaos tinggi, hasil bisa sangat liar)";

    DIM_out(`
        <hr>
        <h2>CFM – CHAOS FRACTAL MODEL</h2>
        <b>Fractal Predictability Index:</b> ${predictability.toFixed(1)} / 100<br>
        <b>Interpretasi:</b> ${label}<br>
        <small>Semakin rendah index, semakin berbahaya untuk over-confidence pada satu skenario.</small>
    `);
}

// ========================================
// 4) DPAI_ – DEEP PATTERN AI (sederhana)
//    Tactical fingerprint berbasis input kunci
// ========================================
function DPAI_runDeepPatternAI(){

    const tempo = DIM_read("tempo_input", 5);
    const chaos = DIM_read("chaos_input", 5);
    const pressH= DIM_read("home_press", 5);
    const pressA= DIM_read("away_press", 5);
    const xgH   = DIM_read("adv_xg_home", 1.2);
    const xgA   = DIM_read("adv_xg_away", 1.0);

    const totalPress = (pressH + pressA) / 2;
    const totalXG    = xgH + xgA;

    let fingerprint = "Balanced Control / Mixed Threat";
    if(totalPress >= 7 && tempo >= 7) fingerprint = "High Press • Vertical Attack • Transition Heavy";
    else if(tempo <= 4 && chaos <= 4) fingerprint = "Low Tempo • Positional Play • Low Risk";
    else if(chaos >= 7) fingerprint = "Broken Shape • Chaos • High Exploit on Error";

    let threatType = "General Chance Creation";
    if(totalXG >= 3) threatType = "High Chance Volume • Likely Multiple Goals";
    else if(totalXG <= 1.8) threatType = "Limited Chance Volume • Fewer Clear Chances";

    DIM_out(`
        <hr>
        <h2>DPAI – DEEP PATTERN AI</h2>
        <b>Tactical Fingerprint:</b> ${fingerprint}<br>
        <b>Chance/Threat Profile:</b> ${threatType}<br>
        <b>Tempo/Chaos:</b> ${tempo} / ${chaos}<br>
        <b>Avg Press:</b> ${totalPress.toFixed(2)} | Total xG: ${totalXG.toFixed(2)}<br>
    `);
}

// ========================================
// 5) FSE_ – FIELD SHAPE ENGINE (versi abstrak)
// ========================================
function FSE_runFieldShape(){

    // Pakai xG & pressing untuk kira-kira shape
    const xgH = DIM_read("adv_xg_home", 1.2);
    const xgA = DIM_read("adv_xg_away", 1.0);
    const pressH = DIM_read("home_press", 5);
    const pressA = DIM_read("away_press", 5);

    const totalXG = xgH + xgA;
    const pressGap= pressH - pressA;

    let spaceControl = "Balanced Zone Control";
    if(pressGap >= 2) spaceControl = "HOME controlling higher zones (pressing line lebih tinggi)";
    else if(pressGap <= -2) spaceControl = "AWAY controlling higher zones / pressing lebih agresif";

    let corridorDanger = "Mixed Corridor Threat";
    if(totalXG >= 3.2) corridorDanger = "High Danger di seluruh lini (halfspace + wide)";
    else if(totalXG <= 1.8) corridorDanger = "Zona bahaya terbatas, sedikit peluang bersih";

    DIM_out(`
        <hr>
        <h2>FSE – FIELD SHAPE ENGINE</h2>
        <b>Space Control:</b> ${spaceControl}<br>
        <b>Corridor Danger:</b> ${corridorDanger}<br>
        Total xG: ${totalXG.toFixed(2)} | Press Gap: ${pressGap.toFixed(2)}<br>
    `);
}

// ========================================
// 6) FTF_ – FUTURE TREND FORECASTER (match ke depan)
// ========================================
function FTF_runFutureTrend(){

    const formH = (DIM_read("adv_form_home_w",0)*2.3 + DIM_read("adv_form_home_d",0)*0.9 - DIM_read("adv_form_home_l",0)*1.8);
    const formA = (DIM_read("adv_form_away_w",0)*2.3 + DIM_read("adv_form_away_d",0)*0.9 - DIM_read("adv_form_away_l",0)*1.8);

    const chaos = DIM_read("chaos_input", 5);
    const imp   = DIM_read("importance_input", 5);

    const trendH = formH - (chaos*0.4) + (imp*0.2);
    const trendA = formA - (chaos*0.4) + (imp*0.2);

    function labelTrend(v){
        if(v >= 6) return "Strong Uptrend";
        if(v >= 2) return "Mild Uptrend";
        if(v <= -6) return "Strong Downtrend";
        if(v <= -2) return "Mild Downtrend";
        return "Sideways / Neutral";
    }

    DIM_out(`
        <hr>
        <h2>FTF – FUTURE TREND FORECASTER</h2>
        <b>Home Future Trend:</b> ${labelTrend(trendH)} (Score: ${trendH.toFixed(2)})<br>
        <b>Away Future Trend:</b> ${labelTrend(trendA)} (Score: ${trendA.toFixed(2)})<br>
        <small>Menggambarkan kecenderungan performa 2–3 match ke depan berdasarkan form + chaos + importance.</small>
    `);
}

// ========================================
// 7) AMI_ – ADAPTIVE MARKET INTELLIGENCE (tanpa odds, murni model)
// ========================================
function AMI_runMarketIntel(){

    const lamH = DIM_read("lamH", 1.0);
    const lamA = DIM_read("lamA", 1.0);
    const chaos= DIM_read("chaos_input", 5);
    const tempo= DIM_read("tempo_input", 5);

    const totalLam = lamH + lamA;
    const balanceGap = Math.abs(lamH - lamA);

    let valueAngle = "Netral (tanpa sisi value mencolok hanya dari model)";
    if(balanceGap >= 0.7) valueAngle = "Model melihat sisi lebih kuat (value potensial di 1X2/handicap sisi dominan)";
    if(totalLam >= 3 && chaos >= 7) valueAngle = "Model menunjukkan potensi high-scoring, value bisa muncul di Over/BTTS jika market terlalu ragu";

    DIM_out(`
        <hr>
        <h2>AMI – ADAPTIVE MARKET INTELLIGENCE</h2>
        <b>Value Angle (berdasar model murni, tanpa odds):</b> ${valueAngle}<br>
        λH/λA: ${lamH.toFixed(3)} / ${lamA.toFixed(3)} | Total: ${totalLam.toFixed(3)}<br>
        Tempo/Chaos: ${tempo} / ${chaos}<br>
    `);
}

// ========================================
// 8) MEO_ – META ENGINE ORCHESTRATOR (BOS DIMENSIONAL)
// ========================================
function MEO_runMetaOrchestrator(){

    // Jalankan semua engine dimensional jika ada
    if(typeof HRE_runHyperReality === "function") HRE_runHyperReality();
    if(typeof GOE_runGeneticOutcome === "function") GOE_runGeneticOutcome();
    if(typeof CFM_runChaosFractal === "function") CFM_runChaosFractal();
    if(typeof DPAI_runDeepPatternAI === "function") DPAI_runDeepPatternAI();
    if(typeof FSE_runFieldShape === "function") FSE_runFieldShape();
    if(typeof FTF_runFutureTrend === "function") FTF_runFutureTrend();
    if(typeof AMI_runMarketIntel === "function") AMI_runMarketIntel();

    // Meta-resume singkat
    const lamH  = DIM_read("lamH", 1.0);
    const lamA  = DIM_read("lamA", 1.0);
    const tempo = DIM_read("tempo_input", 5);
    const chaos = DIM_read("chaos_input", 5);

    const totalLam = lamH + lamA;
    let metaMsg = "Multi-engine menyimpulkan match ini masih dalam spektrum normal (tidak super ekstrem).";

    if(chaos >= 7 && totalLam >= 3){
        metaMsg = "Meta-engine membaca match ini sebagai: LIAR / HIGH-SCORING / VOLATILE. Hati-hati dengan over-commit.";
    } else if(chaos <= 4 && totalLam <= 2.2){
        metaMsg = "Meta-engine membaca match ini sebagai: TIGHT / TACTICAL / LOW-SCORING. Edges lebih halus (under, correct score, Handicap kecil).";
    }

    DIM_out(`
        <hr>
        <h2>MEO – META ENGINE ORCHESTRATOR</h2>
        <b>Meta Conclusion:</b> ${metaMsg}<br>
        Total λ: ${totalLam.toFixed(3)} | Tempo/Chaos: ${tempo} / ${chaos}<br>
        <small>MEO mengorkestrasi seluruh Dimensional Engine untuk memberi gambaran akhir secara makro.</small>
    `);
}
  </script>
  <script>
// ===================================================
// V21 HELPERS – aman, tidak menimpa engine lain
// ===================================================
function V21_read(id, fallback = 0){
    const el = document.getElementById(id);
    if(!el) return fallback;
    const v = parseFloat(el.value);
    if(isNaN(v) || !isFinite(v)) return fallback;
    return v;
}

function V21_readText(id, fallback = ""){
    const el = document.getElementById(id);
    if(!el) return fallback;
    return (el.value || "").toString();
}

function V21_out(html){
    const out = document.getElementById("output");
    if(out) out.innerHTML += html;
}

// ===================================================
// 1) HOME–AWAY CONTEXT ENGINE
// ===================================================
function V21_homeAwayContext(){

    const xgH = V21_read("adv_xg_home", 1.2);
    const xgA = V21_read("adv_xg_away", 1.0);

    const fwH = V21_read("adv_form_home_w",0);
    const fdH = V21_read("adv_form_home_d",0);
    const flH = V21_read("adv_form_home_l",0);

    const fwA = V21_read("adv_form_away_w",0);
    const fdA = V21_read("adv_form_away_d",0);
    const flA = V21_read("adv_form_away_l",0);

    const formH = fwH*2.3 + fdH*0.9 - flH*1.8;
    const formA = fwA*2.3 + fdA*0.9 - flA*1.8;

    const imp  = V21_read("importance_input",5);

    // Simple home advantage base (bisa diperkuat nanti)
    const homeBase = 0.4 * imp;
    const ratingH  = (xgH*0.5 + formH*0.4) + homeBase;
    const ratingA  = (xgA*0.5 + formA*0.4);

    const diff = ratingH - ratingA;

    let label = "Balanced (home-away relatif seimbang)";
    if(diff >= 4) label = "HOME Advantage kuat (venue + form + xG lebih baik)";
    else if(diff >= 2) label = "HOME sedikit di atas";
    else if(diff <= -4) label = "AWAY Advantage kuat (form/xG away lebih tajam)";
    else if(diff <= -2) label = "AWAY sedikit di atas";

    V21_out(`
        <hr>
        <h3>V21 – HOME–AWAY CONTEXT</h3>
        Rating Home: ${ratingH.toFixed(2)}<br>
        Rating Away: ${ratingA.toFixed(2)}<br>
        Gap: ${diff.toFixed(2)}<br>
        Interpretasi: <b>${label}</b><br>
    `);
}

// ===================================================
// 2) INJURIES IMPACT ENGINE
//    Input (opsional, kalau belum ada → dianggap 0):
//    inj_home_key, inj_home_other, inj_away_key, inj_away_other
// ===================================================
function V21_injuryImpact(){

    const hKey   = V21_read("inj_home_key", 0);
    const hOther = V21_read("inj_home_other", 0);
    const aKey   = V21_read("inj_away_key", 0);
    const aOther = V21_read("inj_away_other", 0);

    // 0–10 skala dampak internal
    const impactH = (hKey*2.5) + (hOther*1.0);
    const impactA = (aKey*2.5) + (aOther*1.0);

    let labelH = "Dampak cedera Home: ringan / normal";
    if(impactH >= 12) labelH = "Dampak cedera Home: BERAT (struktur bisa berubah)";
    else if(impactH >= 6) labelH = "Dampak cedera Home: SEDANG (tim sedikit turun kualitas)";

    let labelA = "Dampak cedera Away: ringan / normal";
    if(impactA >= 12) labelA = "Dampak cedera Away: BERAT (struktur bisa berubah)";
    else if(impactA >= 6) labelA = "Dampak cedera Away: SEDANG (tim sedikit turun kualitas)";

    V21_out(`
        <hr>
        <h3>V21 – INJURIES IMPACT</h3>
        Index Cedera Home: ${impactH.toFixed(2)} → ${labelH}<br>
        Index Cedera Away: ${impactA.toFixed(2)} → ${labelA}<br>
        <small>Kalau input cedera belum dibuat di UI, nilai dianggap 0 (no impact).</small>
    `);
}

// ===================================================
// 3) WEATHER IMPACT ENGINE
//    Input opsional: <select id="weather_type">
//    value bisa: "normal", "rain", "heavy_rain", "wind", "hot"
// ===================================================
function V21_weatherImpact(){

    const weather = V21_readText("weather_type","normal").toLowerCase();
    const tempo   = V21_read("tempo_input",5);
    const chaos   = V21_read("chaos_input",5);

    let tempoAdj  = 0;
    let chaosAdj  = 0;
    let desc      = "Cuaca normal, tidak banyak mengubah model.";

    if(weather === "rain"){
        tempoAdj = -0.8;
        chaosAdj = +0.6;
        desc = "Hujan: tempo sedikit turun, error & chaos naik sedikit.";
    } else if(weather === "heavy_rain"){
        tempoAdj = -1.5;
        chaosAdj = +1.2;
        desc = "Hujan deras: tempo turun, banyak error & duel fisik → chaos naik signifikan.";
    } else if(weather === "wind"){
        tempoAdj = -0.3;
        chaosAdj = +0.8;
        desc = "Angin kencang: crossing / bola atas lebih random, chaos naik.";
    } else if(weather === "hot"){
        tempoAdj = -1.0;
        chaosAdj = -0.3;
        desc = "Panas: tempo turun, pemain menghemat tenaga, chaos sedikit turun.";
    }

    const newTempo = Math.max(0, Math.min(10, tempo + tempoAdj));
    const newChaos = Math.max(0, Math.min(10, chaos + chaosAdj));

    V21_out(`
        <hr>
        <h3>V21 – WEATHER IMPACT</h3>
        Tipe Cuaca: ${weather || "normal"}<br>
        Tempo awal: ${tempo} → <b>${newTempo.toFixed(1)}</b><br>
        Chaos awal: ${chaos} → <b>${newChaos.toFixed(1)}</b><br>
        Interpretasi: ${desc}<br>
    `);
}

// ===================================================
// 4) MATCH STATE SIMULATION (LEADING / TRAILING)
// ===================================================
function V21_matchStateSim(){

    const lamH  = V21_read("lamH",1.0);
    const lamA  = V21_read("lamA",1.0);
    const tempo = V21_read("tempo_input",5);
    const chaos = V21_read("chaos_input",5);

    const totalLam = lamH + lamA;

    let whenHomeLeads = "Home cenderung turunkan sedikit tempo dan lebih compact.";
    let whenHomeLoses = "Home akan naikkan tempo & pressing untuk mengejar.";

    if(tempo >= 7 && chaos >= 7){
        whenHomeLeads += " Namun karena chaos tinggi, tetap ada risiko kebobolan balasan.";
        whenHomeLoses += " Laga bisa jadi super liar di babak akhir.";
    } else if(tempo <= 4 && chaos <= 4){
        whenHomeLeads = "Home kemungkinan parkir blok / low block untuk menjaga skor.";
        whenHomeLoses = "Home susah buka tempo, comeback butuh momen bola mati / kesalahan lawan.";
    }

    let OUimpact = "Total goal model sekitar " + totalLam.toFixed(2) + ".";
    if(totalLam >= 3.0) OUimpact += " Kondisi ini mendukung skenario Over, terutama jika tim yang tertinggal agresif.";
    else if(totalLam <= 2.2) OUimpact += " Kondisi ini mendukung Under, apalagi jika tim unggul bermain aman.";

    V21_out(`
        <hr>
        <h3>V21 – MATCH STATES SIMULATION</h3>
        Jika HOME unggul: ${whenHomeLeads}<br>
        Jika HOME tertinggal: ${whenHomeLoses}<br>
        Efek ke OU: ${OUimpact}<br>
    `);
}

// ===================================================
// 5) TEAM IDENTITY FACTOR
//    Input opsional: team_identity_home, team_identity_away (text/select)
//    Contoh value: "possession", "counter", "vertical", "low_block", "gegenpress"
// ===================================================
function V21_teamIdentity(){

    const idH = V21_readText("team_identity_home","unknown").toLowerCase();
    const idA = V21_readText("team_identity_away","unknown").toLowerCase();

    function labelIdentity(id){
        switch(id){
            case "possession": return "Team posisional / kontrol bola tinggi.";
            case "counter":    return "Team counter-attack / transisi cepat.";
            case "vertical":   return "Team vertical direct / main cepat ke depan.";
            case "low_block":  return "Team low block / deep defending.";
            case "gegenpress": return "Team high press / gegenpressing.";
            default:           return "Identity tidak spesifik / hybrid.";
        }
    }

    V21_out(`
        <hr>
        <h3>V21 – TEAM IDENTITY</h3>
        HOME: ${labelIdentity(idH)}<br>
        AWAY: ${labelIdentity(idA)}<br>
        <small>Jika input identity belum dibuat di UI, dianggap 'hybrid'.</small>
    `);
}

// ===================================================
// 6) PLAYER STRENGTH RATIO (ATTACK vs DEFENSE QUALITY)
//    Input opsional:
//    att_rating_home, def_rating_home, att_rating_away, def_rating_away (0–10)
// ===================================================
function V21_playerStrength(){

    const attH = V21_read("att_rating_home",6.5);
    const defH = V21_read("def_rating_home",6.5);
    const attA = V21_read("att_rating_away",6.5);
    const defA = V21_read("def_rating_away",6.5);

    const offEdgeH = attH - defA;
    const offEdgeA = attA - defH;

    let sidePref = "Kedua sisi punya peluang serangan yang cukup seimbang.";
    if(offEdgeH >= 1.5 && offEdgeH > offEdgeA) sidePref = "Serangan HOME punya edge lebih besar ke pertahanan AWAY.";
    else if(offEdgeA >= 1.5 && offEdgeA > offEdgeH) sidePref = "Serangan AWAY punya edge lebih besar ke pertahanan HOME.";

    V21_out(`
        <hr>
        <h3>V21 – PLAYER STRENGTH INDEX</h3>
        Attack HOME: ${attH} vs Defense AWAY: ${defA} → Edge: ${offEdgeH.toFixed(2)}<br>
        Attack AWAY: ${attA} vs Defense HOME: ${defH} → Edge: ${offEdgeA.toFixed(2)}<br>
        Interpretasi: ${sidePref}<br>
    `);
}

// ===================================================
// 7) REFEREE & VAR BIAS MODEL
//    Input opsional:
//    ref_strictness (0–10), ref_pen_bias_home, ref_pen_bias_away (0–10)
// ===================================================
function V21_refVarImpact(){

    const strict = V21_read("ref_strictness",5);
    const penH   = V21_read("ref_pen_bias_home",5);
    const penA   = V21_read("ref_pen_bias_away",5);

    const cardIndex = strict * 1.8;
    const penIndexH = (strict*0.5) + (penH*1.2);
    const penIndexA = (strict*0.5) + (penA*1.2);

    let cardLabel = "Kecenderungan kartu: normal.";
    if(cardIndex >= 14) cardLabel = "Kecenderungan kartu: tinggi (potensi banyak kartu).";
    else if(cardIndex <= 6) cardLabel = "Kecenderungan kartu: rendah (wasit longgar).";

    let penSide = "Peluang penalti relatif seimbang.";
    if(penIndexH - penIndexA >= 3) penSide = "Ada bias penalti condong ke HOME (secara probabilitas).";
    else if(penIndexA - penIndexH >= 3) penSide = "Ada bias penalti condong ke AWAY (secara probabilitas).";

    V21_out(`
        <hr>
        <h3>V21 – REFEREE & VAR IMPACT</h3>
        Card Intensity Index: ${cardIndex.toFixed(2)} → ${cardLabel}<br>
        Penalty Index HOME: ${penIndexH.toFixed(2)}<br>
        Penalty Index AWAY: ${penIndexA.toFixed(2)}<br>
        Interpretasi: ${penSide}<br>
    `);
}

// ===================================================
// 8) V21 SUITE – jalankan semua modul v21
// ===================================================
function V21_runSuite(){
    V21_homeAwayContext();
    V21_injuryImpact();
    V21_weatherImpact();
    V21_matchStateSim();
    V21_teamIdentity();
    V21_playerStrength();
    V21_refVarImpact();
    V21_out(`
        <hr><h3>V21 SUITE COMPLETED</h3>
        <small>Seluruh modul v21 sudah dieksekusi berdasarkan input yang tersedia.</small>
    `);
}
  </script>
  <!-- ===================================================== -->
<!-- BRM – BANKROLL & PARLAY UPGRADE LAYER (AMAN READ-ONLY) -->
<!-- ===================================================== -->
<script>
function BRM_read(id, fallback = 0){
  const el = document.getElementById(id);
  if(!el) return fallback;
  const v = parseFloat(el.value);
  if(isNaN(v) || !isFinite(v)) return fallback;
  return v;
}
function BRM_readText(id, fallback = ""){
  const el = document.getElementById(id);
  if(!el) return fallback;
  return (el.value || "").toString().trim();
}
function BRM_out(html){
  const out = document.getElementById("output");
  if(out) out.innerHTML += html;
}

/* ================================================
   1) BANKROLL & RISK ENGINE (read-only, aman)
   ================================================ */
function BRM_runBankrollAdvisor(){
  const lamH   = BRM_read("lamH", 1.0);
  const lamA   = BRM_read("lamA", 1.0);
  const tempo  = BRM_read("tempo_input", BRM_read("tempo", 5));
  const chaos  = BRM_read("chaos_input", BRM_read("chaos", 5));
  const pressH = BRM_read("home_press", 5);
  const pressA = BRM_read("away_press", 5);
  const totalLam = lamH + lamA;
  const avgPress = (pressH + pressA)/2;

  const bankroll = BRM_read("bankroll", 0);
  const profile  = BRM_readText("risk_profile", "normal").toLowerCase();

  let risk = 0;
  risk += chaos * 4.0;
  risk += Math.max(0, (totalLam - 2.5)) * 7.0;
  risk += Math.max(0, (avgPress - 6)) * 3.5;
  risk += Math.max(0, (tempo - 6)) * 2.5;
  risk = Math.max(0, Math.min(100, risk));

  let riskLabel = "Moderate Risk";
  if(risk >= 75) riskLabel = "HIGH RISK • Varians tinggi.";
  else if(risk <= 35) riskLabel = "LOW RISK • Stabil.";

  let basePct = 1.0;
  if(profile === "conservative") basePct = 0.5;
  else if(profile === "aggressive") basePct = 2.0;

  if(risk >= 75) basePct *= 0.6;
  else if(risk <= 35) basePct *= 1.2;

  const safePct = Math.max(0.2, Math.min(3.0, basePct));

  let moneyText = "";
  if(bankroll > 0){
    const stake = bankroll * (safePct/100);
    moneyText = `Stake aman ≈ <b>${safePct.toFixed(2)}%</b> (${stake.toFixed(2)} uang).<br>`;
  } else {
    moneyText = `Stake aman ≈ <b>${safePct.toFixed(2)}%</b> dari bankroll.<br>`;
  }

  BRM_out(`
    <hr>
    <h2>BRM – BANKROLL & RISK ENGINE</h2>
    Risk Index: <b>${risk.toFixed(1)}</b><br>
    Level: ${riskLabel}<br>
    Profil: ${profile}<br>
    ${moneyText}
  `);
}

/* ================================================
   2) PARLAY HELPER
   ================================================ */
function BRM_runParlayHelper(){
  const chaos  = BRM_read("chaos_input", BRM_read("chaos", 5));
  const tempo  = BRM_read("tempo_input", BRM_read("tempo", 5));
  const lamH   = BRM_read("lamH", 1.0);
  const lamA   = BRM_read("lamA", 1.0);
  const totalLam = lamH + lamA;

  const profile = BRM_readText("risk_profile", "normal").toLowerCase();

  let maxLeg = 4;
  if(profile === "conservative") maxLeg = 2;
  else if(profile === "aggressive") maxLeg = 6;

  if(chaos >= 7) maxLeg = Math.max(2, maxLeg - 1);
  else if(chaos <= 4) maxLeg += 1;
  maxLeg = Math.max(2, Math.min(8, maxLeg));

  let hint = "Cocok untuk parlay pendek.";
  if(totalLam >= 3 && chaos >= 7) hint = "Cocok untuk parlay GOAL (Over/BTTS).";
  else if(totalLam <= 2.2 && chaos <= 4) hint = "Cocok untuk Under / Draw-ish.";

  BRM_out(`
    <hr>
    <h2>BRM – PARLAY HELPER</h2>
    Saran jumlah leg maksimal: <b>${maxLeg}</b><br>
    Lingkungan: λ total ${totalLam.toFixed(2)}, chaos ${chaos.toFixed(1)}<br>
    Hint: ${hint}<br>
  `);
}

/* ================================================
   3) EDGE CLASSIFIER
   ================================================ */
function BRM_runEdgeClassifier(){
  const lamH   = BRM_read("lamH", 1.0);
  const lamA   = BRM_read("lamA", 1.0);
  const tempo  = BRM_read("tempo_input", BRM_read("tempo", 5));
  const chaos  = BRM_read("chaos_input", BRM_read("chaos", 5));
  const imp    = BRM_read("importance_input", BRM_read("importance", 5));

  const diff = lamH - lamA;
  const totalLam = lamH + lamA;

  let type = "Netral (semua market valid).";
  let focus = "Tidak ada edge kuat.";

  if(Math.abs(diff) >= 0.7){
    if(diff > 0){
      type = "Side → HOME advantage.";
      focus = "Cocok 1X / DNB / Handicap Home.";
    } else {
      type = "Side → AWAY advantage.";
      focus = "Cocok X2 / DNB / Handicap Away.";
    }
  } else if(totalLam >= 3 && chaos >= 6){
    type = "Goal Edge → High scoring.";
    focus = "Fokus: Over / BTTS / multi-goal.";
  } else if(totalLam <= 2.2 && chaos <= 4){
    type = "Low scoring edge.";
    focus = "Fokus: Under / Draw-ish / DNB kecil.";
  }

  BRM_out(`
    <hr>
    <h2>BRM – EDGE CLASSIFIER</h2>
    λH/λA: ${lamH.toFixed(3)} / ${lamA.toFixed(3)}<br>
    Edge: <b>${type}</b><br>
    Fokus market: ${focus}<br>
  `);
}

/* ================================================
   4) MASTER – BRM PARLAY SUITE
   ================================================ */
function BRM_runParlaySuite(){
  BRM_runBankrollAdvisor();
  BRM_runParlayHelper();
  BRM_runEdgeClassifier();
  BRM_out(`
    <hr><h3>BRM SUITE SELESAI</h3>
  `);
}
</script>
</body>
  </html>
